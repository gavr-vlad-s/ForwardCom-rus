% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Заключение}
Предлагаемая архитектура набора команд, ForwardCom, является последовательным, модульным, гибким, ортогональным, масштабируемым, и расширяемым набором команд, предлагающим хороший компромисс между принципом RISC, дающим быстрое декодирование, и принципом CISC, дающим более компактный код и выполнение большей работы в расчёте на одну команду. У каждой команды есть много разных вариантов кодирования, с разными типами операндов, разными режимами адресации памяти, со скалярами, векторами, предикатами, масками, и разрядами опций. Поддержка эффективной обработки векторов и неупорядоченного выполнения является базовой частью дизайна,  а не неоптимальной заплаткой, добавляемой позднее, что мы видели в других системах.

Обычные команды, такие, как, например, сложение, могут быть закодированы в виде многих разных форматов, с целочисленными операндами разных размеров и вещественными операндами разной точности. Операнды могут быть скалярами либо векторами любой длины. Операнды могут быть регистрами, непосредственно заданными константами, или находящимися в памяти операндами, с разными режимами адресации. Всё во всём, одна и та же базовая команда может иметь много разных вариантов с одним и тем же кодом операции, когда у других наборов команд имеется много разных команд для охвата того же разнообразия. Это упрощает реализацию аппаратуры. В дизайне также есть много места для одноформатных команд с меньшим количеством вариантов.

Команды проектируются так, чтобы конвейер микропроцессора мог быть простым и эффективным. Все команды помещаются в одну простую и логичную систему шаблонов, что сделает создание и аппаратуры, и программного обеспечения  более простым и эффективным.

Препроцессор декодера может загружать много команд за такт, поскольку ему легко обнаруживать длину каждой команды, и декодеру нужно различать лишь небольшое количество разных размеров команд. В действительности, единственным размером команды, который обязательно должен поддерживаться, является одинарное слово. Возможно создание работающих программ лишь с помощью однословных (32--разрядных) команд, но чрезвычайно рекомендуется также поддерживать команды размером в два слова. Трёхсловные команды --- удобны, и могут поддерживаться, если могут быть реализованы без уменьшения суммарной скорости декодирования. Малые команды  (две в одном слове кода) полезны для того, чтобы сделать код более компактным.

В последующих расширениях возможно добавление поддержки более длинных команд, но приоритет состоял в устранении любого узкого места в декодировании длины команды, являющегося серьёзным узким местом в архитектуре x86. 

Формат кода проектировался с тем, чтобы быть компактным, дабы сэкономить место в кэше кода. Эта компактность достигается несколькими способами. Одни и те же команды могут быть закодированы в виде разных размеров, с двухоперандными и трёхоперандными формами, разными размерами непосредственно заданных констант, сдвинутыми непосредственно заданными константами, и относительными адресами с разных размеров смещениями и масштабирующими множителями, избегая абсолютных адресов, которые потребовали бы 64 разряда для одного лишь адреса. Всегда можно выбрать наименьшую (по размеру) версию команды, удовлетворяющую конкретной надобности. Нагрузку на кэш данных можно уменьшить, сохраняя непосредственные константы в коде, а не в находящихся в памяти операндах.

У большинства команд может иметься регистр маски, который используется в качестве предиката в скалярных командах и маскирования в векторных. Тот же самый регистр маски используется также для указания различных опций, таких, как режим округления, обработка исключений, и т.п., которые в противном случае потребовали бы дополнительных разрядов  в коде команды.

Введение векторных регистров переменной длины является важным улучшением по сравнению с большинством распространённых нынешних архитектур. Векторная система  ForwardCom имеет следующие преимущества.
\begin{itemize}
\item Система является масштабируемой. Разные микропроцессоры могут иметь разные максимальные длины векторов, без ограничения сверху. Её можно использовать в малых встроенных системах, а равно в больших суперкомпьютерах с очень длинными векторами.

\item Один и тот же код может выполняться на разных микропроцессорах, с разными максимальными размерами длин векторов, и автоматически использовать возможности каждого микропроцессора.

\item При появлении новой версии микропроцессора, с более длинными векторами, код перекомпилировать не нужно. Разработчики программного обеспечения не должны сопровождать много версий своего программного обеспечения для разных длин векторов.

\item Программное обеспечение может сохранять и восстанавливать векторный регистр способом, который гарантированно будет работать на последующих процессорах, с более длинными векторами. Неспособность сделать так --- большая проблема в нынешних архитектурах.

\item Необходимо сохранять и восстанавливать лишь ту часть векторного регистра, которая действительно используется. Каждый векторный регистр включает в себя сведения о том, сколько байтов в нём используется. Следовательно, не нужно тратить ресурсы на сохранение полноразмерного вектора, если он не используется или используется лишь частично.

\item Специальный адресный режим поддерживает очень эффективную структуру цикла, автоматически использующего максимальную длину вектора на всех итерациях цикла по массиву, кроме последней. Последняя итерация будет автоматически использовать более короткий вектор, чтобы обработать оставшиеся элементы массива, в случае, когда размер массива не кратен максимальной длине вектора.  Нет нужды отдельно, вне основного цикла, обрабатывать оставшиеся элементы, и нет нужды создавать отдельные версии цикла для разных специальных случаев.

\item Функции могут иметь в качестве параметров векторы переменной длины, что облегчает компилятору векторизацию циклов, содержащих вызовы функций.

\item Командам с векторными регистровыми операндами не нужны дополнительные сведения о длине вектора, ибо эти сведения включены в векторные регистры, что делает эти команды более компактными. Однако командам, работающим с векторными операндами, находящимися в памяти, эти сведения нужны.

\item Система учитывает специальные потребности микропроцессоров с очень длинными векторами, у которых задержки переноса по вектору могут зависеть от длины вектора.
\end{itemize}

Модель памяти является гибкой, с относительными адресами. Ничего не зависит от местоположения. Управление памятью --- проще, чем в имеющихся системах, с меньшей необходимостью в трансляции виртуальных адресов. Буфера ассоциативной трансляции (translation lookaside buffer, TLB) и разбиения памяти на страниц нет, но есть простая карта памяти, находящаяся на кристалле. Проблемы с переполнением стека, фрагментацией памяти, и т.п., в большинстве случаев можно полностью устранить. Переключение задач будет быстрым, из--за малой карты памяти и из--за эффективного механизма сохранения векторных регистров.

Принцип, состоящий в коренном перепроектировании, позволяет нам изучить историю и интегрировать последние дополнения в базовый дизайн, также применяется ко всей экосистеме стандартов прикладного двоичного интерфейса (ABI), библиотек функций, компиляторов, компоновщиков, и операционной системе. Определяя не только набор команд, но также и стандарты ABI, двоичные форматы файлов, стандарты библиотек интерфейса, и т.п., мы получим ещё одно преимущество, заключающееся в том, что разные компиляторы и  разные языки программирования будут совместимы друг с другом. Будет возможным написание разных частей программы на разных языках программирования и использование одних и тех же библиотек функций с разными компиляторами. В некоторой степени будут совместимы даже разные операционные системы. Не невозможной целью мог бы быть и запуск одного и того же двоичного файла программы в разных операционных системах.

Мы также изучили прошлые ошибки, состоящие в том, что сложно предсказать будущие потребности. В то время как набор команд ForwardCom предназначен для того, чтобы быть гибким, с пространством для последующих расширений, мы можем спросить: не принесёт ли будущее новых черт, которые сложно интегрировать в наши дизайн и стандарты? Лучший способ предотвратить такие непредвиденные проблемы --- разрешить приём предложений от всего сообщества разработчиков, и аппаратуры, и программного обеспечения. Важно, чтобы дизайн и стандарты разрабатывались с помощью открытого процесса, позволяющего всем комментировать и вносить предложения. Мы уже видели проблемы, когда это отдаётся коммерческой промышленности. Промышленность часто, по маркетинговым причинам, принимает краткосрочные решения. Патенты, лицензионные ограничения, и торговые секреты наносят урон конкуренции, и мешают выходу на рынок нишевых операторов. Новые черты и расширения набора команд по причинам, связанным с конкуренцией, хранятся в тайне, пока не станет слишком поздно, чтобы изменить их, в случае, когда сообщество ИТ предлагает более хорошие варианты.

Проект ForwardCom разрабатывается как вклад в процесс открытой разработки, основанный на философии, заключающейся в том, что этих проблем можно избежать с помощью открытости и сотрудничества.
\end{document}