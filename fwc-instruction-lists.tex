\documentclass[forwardcom.tex]{subfiles}
\begin{document}

\chapter{Списки команд}
Команды ForwardCom перечислены в файле с разделителями в виде запятых, который называется instruction\_list.csv. Этот файл предназначен для использования ассемблерами, дизассемблерами, отладчиками, и эмуляторами. Данный список предварителен, и, возможно, изменится. Пожалуйста, помните, что списки в этом документе синхронизированы со списком в instruction\_list.cvs.

Этот список команд имеет следующие поля:

\begin{longtable} {|p{18mm}|p{130mm}|}\caption{Поля в файле со списком команд} 
\label{table:fieldsInInstructionListFile}
\\
\endfirsthead
\endhead
\hline
\bfseries Поле  & \bfseries Смысл  \\ \hline
Name            & Имя команды, используемое ассемблером.  \\ \hline
Category        & 1: одноформатная команда, \newline
2: малая команда,  \newline
3: многоформатная команда,  \newline
4: команда перехода. \\ \hline
Formats         & См. приводимую ниже табл.~\ref{table:MeaningOfFormatsFieldInInstructionListFile}.  \\ \hline
Template        & Шестнадцатиричное число: \newline
0xA--0xE для шаблонов A--E,  \newline
0x1 для малого шаблона,  \newline
0x0 для множественных шаблонов. \\ \hline

Source operands & Количество операндов--источников, включая регистровые операнды, находящиеся в памяти операнды, и непосредственно заданные операнды, но не включая маску, разряды опций, длину вектора, и индекс. \\ \hline
OP1             & Код операции, OP1. \\ \hline
OP2             & Дополнительный код операции, OP2. Ноль, если нет. \\ \hline
OP3 bits\newline used   & Количество разрядов в поле OP3, используемых для опций. Поле OP3 для счётчика сдвига в форматах 2.5 и 2.9 только если указанное здесь значение равно нулю. \\ \hline
Operand types general purpose registers & Шестнадцатиричное число, указывающее требуемую и необязательную поддержку каждого из типов операндов для регистров общего назначения. По поводу смысла каждого разряда см. приводимую ниже табл.~\ref{table:OperandTypesInInstructionList}. \\ \hline
Operand types scalar & Шестнадцатиричное число, указывающее требуемую и необязательную поддержку каждого из типов операндов для скалярных операций в векторных регистрах. По поводу смысла каждого разряда см. приводимую ниже табл.~\ref{table:OperandTypesInInstructionList}. \\ \hline
Operand types vector & Шестнадцатиричное число, указывающее требуемую и необязательную поддержку каждого из типов операндов для векторных операций. По поводу смысла каждого разряда см. приводимую ниже табл.~\ref{table:OperandTypesInInstructionList}. \\ \hline
Immediate operand type & Тип непосредственно заданного операнда для одноформатных команд. См. приводимую ниже табл.~\ref{table:immediateOperantTypesInInstructionList}. \\ \hline
Description & Описания команды и комментарии. \\ \hline
\end{longtable}

\pagebreak % The text in the multirow box below disappears if there is a page break in it. 
% Put page break here instead to prevent this
\label{table-format-field-in-list}
\begin{longtable} {|p{26mm}|p{16mm} p{100mm}|}
\caption{Смысл полей формата в файле со списком команд} \label{table:MeaningOfFormatsFieldInInstructionListFile}\\
\endfirsthead
\endhead
\hline
\bfseries Категория & \multicolumn{2}{|l|}{\bfseries Интерпретация полей форматов} \\
\hline
1.  Одноформатная команда. & \multicolumn{2}{|p{120mm}|}{
Число из трёх шестнадцатиричных цифр. Крайняя левая цифра --- значение поля IL (0-3). 
Средняя цифра --- значение поля Mode, или комбинированного поля M+Mode (0-9).
Крайняя правая цифра --- подрежим, определяемый полем OP3 в форматах 2.4.x и 2.8.x, или OP1 в формате 2.7.x. Иначе нуль. 
Например, 0x283 означает формат 2.8.3.
}  \\ \hline
\multirow{11}{*}{\parbox{26mm}{2. Малая команда}} 
&  0 & Нет операндов. \\
&  1 & RD = операнд--приёмник, являющийся регистром общего назначения, RS = непосредственно заданный операнд. \\
&  2 & RD = операнд--приёмник, являющийся РОН\footnote{Регистр общего назначения}, RS = регистр источник, являющийся РОН. \\
&  4 & RD = операнд--приёмник, являющийся РОН, RS = указатель на находящийся в памяти операнд--источник. \\
&  5 & RD = операнд--источник, являющийся РОН, RS = указатель на находящийся в памяти операнд--приёмник. \\
&  8 & RD = операнд--приёмник, являющийся векторным регистром, RS --- неиспользуется. \\
&  9 & RD = операнд--приёмник, являющийся векторным регистром, RS --- непосредственно заданный операнд. \\
& 10 & RD = операнд--приёмник, являющийся векторным регистром, RS --- являющий векторным регистром источник. \\
& 11 & RD = операнд--источник, являющийся вектоным регистром, RS --- являющийся приёмником РОН r0-r14,r31. \\
& 12 & RD = операнд--приёмник, являющийся векторным регистром, RS = указатель на находящийся в памяти операнд--источник. \\
& 13 & RD = операнд--источник, являющийся вектоным регистром, RS = указатель на находящийся в памяти операнд--приёмник. \\ \hline
%	% \pagebreak % The text in the multirow box disappears if there is a page break in it. 
%	% Put pagebreak here to prevent this, or before the table
%	% \hline
\multirow{27}{*}{\parbox[t]{26mm}{3. Многоформатная команда}} 
	&  \multicolumn{2}{|p{120mm}|}{Шестнадцатиричное число, составленное из разрядов, каждый из которых отвечает за поддержку своего формата:} \\
	&  0x0000001 & Формат 0.0: три регистра общего назначения. \\
	&  0x0000002 & Формат 0.1: два регистра общего назначения и 8--разрядное непосредственно заданное значение. \\
	&  0x0000004 & Формат 0.2: три векторных регистра. \\
	&  0x0000008 & Формат 0.3: два векторных регистра и 8--разрядное непосредственно заданное значение. \\
	&  0x0000010 & Формат 0.4: один вектор и находящийся в памяти операнд. \\
	&  0x0000020 & Формат 0.5: один вектор и находящийся в памяти операнд с отрицательным индексом. \\
	&  0x0000040 & Формат 0.6: один вектор и находящийся в памяти скалярный операнд с индексом. \\
	&  0x0000080 & Формат 0.7: один вектор и находящийся в памяти скалярный операнд с 8--разрядным смещением. \\
	&  0x0000100 & Формат 0.8: один РОН и находящийся в памяти операнд с индексом. \\
	&  0x0000200 & Формат 0.9: один РОН и находящийся в памяти операнд с 8--разрядным смещением. \\
	&  0x0000400 & Формат 2.0: два РОН и находящийся в памяти операнд с 32--разрядным смещением. \\
	&  0x0000800 & Формат 2.1: три РОН и 32--разрядное непосредственно заданное значение. \\
	&  0x0001000 & Формат 2.2: один векторный регистр и находящийся в памяти операнд с 32--разрядным смещением. \\
	&  0x0002000 & Формат 2.3: три векторных регистра и 32--разрядное непосредственно заданное значение. \\
	&  0x0004000 & Формат 2.4.0: два векторных регистра и находящийся в памяти скалярный операнд с 16--разрядным смещением. \\
	&  0x0008000 & Формат 2.4.1: два векторных регистра и находящийся в памяти операнд с 16--разрядным смещением. \\
	&  0x0010000 & Формат 2.4.2: два векторных регистра и находящийся в памяти операнд с отрицательным индексом. \\
	&  0x0020000 & Формат 2.4.3: два векторных регистра и находящийся в памяти скалярный операнд с индексом и лимитом. \\
	&  0x0040000 & Формат 2.5: три векторных регистра и сдвинутое 16--разрядное непосредственно заданное значение. \\
	&  0x0080000 & Формат 2.8.0: три РОН и находящийся в памяти операнд с 16--разрядным смещением. \\
	&  0x0100000 & Формат 2.8.1: два РОН и находящийся в памяти операнд с немасштабируемым индексом. \\
	&  0x0200000 & Формат 2.8.2: два РОН и находящийся в памяти операнд с масштабируемым индексом. \\
	&  0x0400000 & Формат 2.8.3: два РОН и находящийся в памяти скалярный операнд с индексом и лимитом. \\
	&  0x0800000 & Формат 2.9: три РОН и сдвинутое 16--разрядное непосредственно заданное значение. \\
	&  0x1000000 & Формат 3.1: три РОН и 64--разрядное непосредственно заданное значение (необязательно). \\
	&  0x2000000 & Формат 3.3: три векторных регистра и 64--разрядное непосредственно заданное значение (необязательно). \\ 	\hline
	\multirow{12}{*}{\parbox[t]{26mm}{4. Команда перехода}} 
	&  \multicolumn{2}{|p{120mm}|}{Шестнадцатиричное число, составленное из разрядов, каждый из которых отвечает за поддержку своего формата:} \\
	&  0x001 & Формат 1.4: два регистра и 8--разрядное смещение. \\
	&  0x002 & Формат 1.5 C: один регистр, 8--разрядное непосредственно заданное значение, и 8--разрядное смещение. \\
	&  0x004 & Формат 1.5 C: 16--разрядное смещение. \\
	&  0x008 & Формат 1.5 D: нет регистра, но есть 24--разрядное смещение. \\
	&  0x010 & Формат 2.7.0: два регистра и 32--разрядное смещение. \\
	&  0x020 & Формат 2.7.1: два регистра, 16--разрядное непосредственно заданное значение, и 16--разрядное смещение. \\
	&  0x040 & Формат 2.7.2: один регистр, 8--разрядное непосредственно заданное значение, и 32--разрядное смещение. \\
	&  0x080 & Формат 2.7.3: один регистр, 32--разрядное непосредственно заданное значение, и 8--разрядное смещение. \\
	&  0x100 & Формат 2.7.4: системный вызов, 16--разрядный ID фунции и 32--разрядный ID модуля. \\
	&  0x200 & Формат 3.0.1: два регистра, 32--разрядное непосредственно заданное значение, и 32--разрядное смещение. \\
	&  0x400 & Формат 3.0.1: 64--разрядный абсолютный адрес. \\ 	\hline
\end{longtable}

\begin{longtable} {|p{18mm}|p{100mm}|}
\caption{Указание типов операндов, поддерживаемых регистрами общего назначения, скалярами в векторных регистрах, или векторами. Данное значение представляет собой шестнадцатиричное число, составленное из разрядов, каждый из которых отвечает за поддержку своего формата} 
\label{table:OperandTypesInInstructionList} \\
\endfirsthead
\endhead
\hline
0x0001 & поддержка 8--разрядных целых                                        \\ 	\hline
0x0002 & поддержка 16--разрядных целых                                       \\ 	\hline
0x0004 & поддержка 32--разрядных целых                                       \\ 	\hline
0x0008 & поддерка 64--разрядных целых                                        \\ 	\hline
0x0010 & поддержка 128--разрядных целых                                      \\ 	\hline
0x0020 & поддержка вещественных чисел одинарной точности                     \\ 	\hline
0x0040 & поддержка вещественных чисел двойной точности                       \\ 	\hline
0x0080 & поддержка вещественных чисел четырёхкратной точности                \\ 	\hline
0x0100 & необязательная поддержка 8--разрядных целых                         \\ 	\hline
0x0200 & необязательная поддержка 16--разрядных целых                        \\ 	\hline
0x0400 & необязательная поддержка 32--разрядных целых                        \\ 	\hline
0x0800 & необязательная поддержка 64--разрядных целых                        \\ 	\hline
0x1000 & необязательная поддержка 128--разрядных целых                       \\ 	\hline
0x2000 & необязательная поддержка вещественных чисел одинарной точности      \\ 	\hline
0x4000 & необязательная поддержка вещественных чисел двойной точности        \\ 	\hline
0x8000 & необязательная поддержка вещественных чисел четырёхкратной точности \\ 	\hline
\end{longtable}

\begin{longtable} {|l|p{140mm}|}
\caption{Тип непосредственно заданного заданного операнда для одноформатных команд} 
\label{table:immediateOperantTypesInInstructionList}
\\
\endfirsthead
\endhead
\hline
0  & нет аргументов или многоформатная команда \\
1  & 4--разрядное знаковое целое число \\
2  & 8--разрядное знаковое целое число \\
3  & 16--разрядное знаковое целое число \\
4  & 32--разрядное знаковое целое число \\
5  & 64--разрядное знаковое целое число \\
6  & 8--разрядное знаковое целое число, сдвигаемое на указанное количество разрядов \\
7  & 16--разрядное знаковое целое число, сдвигаемое на указанное количество разрядов \\
8  & 16--разрядное знаковое целое число, сдвигаемое на 16 разрядов \\
9  & 32--разрядное знаковое целое число, сдвигаемое на 32 разрядов \\
17 & 4--разрядное беззнаковое целое число \\
18 & 8--разрядное беззнаковое целое число \\
19 & 16--разрядное беззнаковое целое число \\
20 & 32--разрядное беззнаковое целое число \\
21 & 64--разрядное беззнаковое целое число \\
33 & 4--разрядное знаковое целое число, преобразуемое в вещественное число \\
34 & 8--разрядное знаковое целое число, преобразуемое в вещественное число \\
35 & 16--разрядное знаковое целое число, преобразуемое в вещественное число \\
39 & 16--разрядное знаковое целое число, сдвигаемое на указанное количество разрядов, и преобразуемое затем в вещественное число \\
64 & вещественное число половинной точности \\
65 & вещественное число одинарной точности \\
66 & вещественное число двойной точности \\ \hline
\end{longtable}

Команды перехода перечислены на с.~\pageref{table:controlTransferInstructions}. Все прочие категории команд перечислены в последующих таблицах.

\section{Список многоформатных команд}
Следующий список команд охватывает общепринятые команды, которые можно закодировать в большинстве форматов или во всех форматах, предназначенных для многоформатных команд.

\begin{longtable} {|p{18mm}|p{9mm}|p{21mm}|p{95mm}|}
\caption{Список многоформатных команд} 
\label{table:ListOfMultiFormatInstructions} \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries OP1 & \bfseries Операндов--источников & \bfseries Описание            \\ \hline
nop               &  0           & 0                                & Нет операции.                 \\
move              &  1           & 1                                & Копирование значения.         \\
store             &  2           & 1                                & Сохранение значения в памяти. \\
prefetch          &  3           & 1                                & Предвыборка из памяти.        \\
sign\_extend      &  4           & 1                                & Расширить меньшее целое знаком до 64 разрядов. \\
add               &  8           & 2                                & src1 + src2. \\
sub               &  9           & 2                                & src1 - src2. \\
sub\_r            & 10           & 2                                & src2 - src1. \\
compare           & 11           & 2                                & Сравнение. Использует коды условий, см. с.~\pageref{table:conditionCodesForCompareInstruction}. \\
mul               & 12           & 2                                & src1 $\cdot$ src2. \\ 
mul\_hi\_s        & 13           & 2                                & (src1 $\cdot$ src2) $\gg$ OS, знаково (только для целых чисел). \\
mul\_hi\_u        & 14           & 2                                & (src1 $\cdot$ src2) $\gg$  OS, беззнаково (только для целых чисел). \\
mul\_ex\_s        & 15           & 2                                & Перемножить элементы с чётными номерами векторов, состоящих из знаковых целых чисел, для получения результатов двойного размера. \\
mul\_ex\_u        & 16           & 2                                & Перемножить элементы с чётными номерами векторов, состоящих из беззнаковых целых чисел, для получения результатов двойного размера. \\
div               & 17           & 2                                & src1 / src2 (необязательно для целочисленных векторов). \\
rem               & 18           & 2                                & Остаток от деления (необязательно для целочисленных векторов). \\
min               & 20           & 2                                & Знаковый минимум. \\
max               & 21           & 2                                & Знаковый максимум. \\
min\_u            & 22           & 2                                & Беззнаковый минимум для целых чисел, минимум из абсолютных величин для вещественных. \\
max\_u            & 23           & 2                                & Беззнаковый максимум для целых чисел, максимум из абсолютных величин для вещественных. \\
and               & 32           & 2                                & src1 \& src2. \\
and\_not          & 33           & 2                                & src1 \& (\~{}src2). \\
or                & 34           & 2                                & src1 \textbar{} src2. \\
xor               & 35           & 2                                & src1 \^{} src2. \\
shift\_left       & 36           & 2                                & src1 $\ll$  src2.  \\
shift\_rightu     & 37           & 2                                & src1 $\gg$ src2, с расширением нулём. \\
shift\_rights     & 38           & 2                                & src1 $\gg$ src2, с расширением знаком. \\
rotate            & 39           & 2                                & Вращать влево, если src2 положительно, и вправо --- если отрицательно. \\
extract\_bit      & 40           & 2                                & Выделить разряд. (src1 $\gg$ src2) \& 1. \\
set\_bit          & 41           & 2                                & Установить разряд. src1 \textbar{} (1 $\ll$ src2). \\
clear\_bit        & 42           & 2                                & Сбросить разряд. src1 \& \~{} (1 $\ll$ src2). \\
toggle\_bit       & 43           & 2                                & Инвертировать разряд. src1 \^{} (1 $\ll$ src2). \\
mul\_add          & 46           & 3                                & $\pm \text{src1} \pm \text{src2} \cdot \text{src3}$ (необязательно). \\
add\_add          & 47           & 3                                & $\pm \text{src1} \pm \text{src2} \pm \text{src3}$ (необязательно). \\
userdef55 -- userdef62 & 55-62 & 2 & Зарезервировано для определяемых пользователем команд. \\
undef             & 63           & 2                                & Неопределённый код. Гарантированно возбуждает прерывание (trap)  во всех будущих реализациях. \\ \hline
\end{longtable}

\section{Список малых команд}
В одном 32--разрядном слове кода помещается две малых команды. Если малая команда не может спариваться ни с чем иным, то она спаривается с малой nop.

Если не оговорено иное, то операнды малых команд --- 64--разрядные. RD --- регистр--приёмник, и, в большинстве случаев, также и первый из регистров--источников. RS может быть одним из регистров r0-r15, v0-v15, либо непосредственно заданной расширенной знаком 4--разрядной константой. Команды с указателем в RS используют в качестве указателя r0-r14, когда RS --- от 0 до 14, и указатель стека (r31), когда RS равно 15.

Поскольку адрес команды должен быть кратен четырём, то невозможно перейти на вторую команду из пары малых команд. Если прерывание или ловушка возникли при выполнении малой команды, то обработчик прерывания должен запомнить, какая из двух малых команд была прервана.

\begin{longtable} {|p{20mm}|p{8mm}|p{100mm}|}
\caption{Список малых команд, работающих с регистрами общего назначения} 
\label{table:tinyInstructionsGP} \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries OP1 & \bfseries Описание \\ \hline
nop               &  0            & Нет операции. \\
move              &  1            & RD = расширенная знаком константа из поля RS. \\
add               &  2            & RD += расширенная знаком константа из поля RS. \\
sub               &  3            & RD --= расширенная знаком константа из поля RS. \\
shift\_left       &  4            & RD $\ll$= беззнаковая константа из поля RS. \\
shift\_rightu     &  5            & RD $\gg$= беззнаковая константа из поля RS (расширение нулём). \\
move              &  8            & RD = регистровый операнд RS. \\
add               &  9            & RD += регистровый операнд RS. \\
sub               & 10            & RD --= регистровый операнд RS. \\
and               & 11            & RD \&= регистровый операнд RS. \\
or                & 12            & RD \textbar= регистровый операнд RS. \\
xor               & 13            & RD \^{}= регистровый операнд RS. \\
move              & 14            & Прочесть RD из находящегося в памяти операнда, имеющего заданный полем RS  (RS = r0-r14, r31) указатель. \\
store             & 15            & Записать RD в находящийся в памяти операнд, имеющий заданный полем RS  (RS = r0-r14, r31) указатель. \\ \hline
\end{longtable}

\begin{longtable} {|p{20mm}|p{8mm}|p{100mm}|}
\caption{Список малых команд, работающих с векторными регистрами}
\label{table:tinyInstructionsVector}  \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries OP1 & \bfseries Описание \\ \hline
clear             & 16            & Очистить регистр RD, установив его длину равной нулю. \\
%move          & 17 & RD = signed 4-bit integer RS, converted to single precision scalar. \\
%move          & 18 & RD = signed 4-bit integer RS, converted to double precision scalar. \\
%move          & 19 & RD = RS. Copy vector of any type. \\
%add           & 20 & RD += RS, single precision float vector. \\
%add           & 21 & RD += RS, double precision float vector. \\
%sub           & 22 & RD --= RS, single precision float vector. \\
%sub           & 23 & RD --= RS, double precision float vector. \\
%mul           & 24 & RD *= RS, single precision float vector. \\
%mul           & 25 & RD *= RS, double precision float vector. \\
%add\_cps      & 28 & Get size of compressed image for RD and add it to general purpose register RS. \\
%sub\_cps      & 29 & Get size of compressed image for RD and subtract it from general purpose register RS. \\
%restore\_cp   & 30 & Restore vector register RD from compressed image pointed to by RS. \\
%save\_cp      & 31 & Save vector register RD to compressed image pointed to by RS. \\
%\hline
\end{longtable}
%
%\section{List of single-format instructions}
%These instructions are mostly available in only one or a few formats.
%
%\begin{longtable} {|p{20mm}|p{10mm}|p{8mm}|p{75mm}|}
%\caption{List of single-format instructions with general purpose registers} 
%\label{table:ListOfSingleFormatInstructionsGP} \\
%\endfirsthead
%\endhead
%\hline
%\bfseries Instruction & \bfseries Format &\bfseries OP1 & \bfseries Description \\
%\hline
%bitscan\_f    & 1.0   &  1 & Bit scan forward. Find index to lowest set bit in RS (optional). \\
%bitscan\_r    & 1.0   &  2 & Bit scan reverse. Find index to highest set bit in RS (optional). \\
%round\_d2     & 1.0   &  3 & Round down RS to nearest power of 2. \\
%round\_u2     & 1.0   &  4 & Round up RS to nearest power of 2. \\
%move          & 1.1   &  0 & Move 16-bit sign-extended constant to general purpose register RD. \\
%move\_u       & 1.1   &  1 & Move 16-bit zero-extended constant to general purpose register RD
%(can be used as first step of loading a 32-bit constant if double size
%instructions are not supported). \\
%add           & 1.1   &  2  & Add 16-bit sign-extended constant to RD. \\
%sub           & 1.1   &  3  & Subtract 16-bit sign-extended constant from RD. \\
%subr          & 1.1   &  4  & Subtract RD from 16-bit sign-extended constant. \\
%mul           & 1.1   &  5  & Multiply RD with 16-bit sign-extended constant. \\
%div           & 1.1   &  6  & Divide RD with 16-bit sign-extended constant. \\
%add           & 1.1   &  7  & Shift 16-bit signed constant left by 16 and add to RD. \\
%move          & 1.1   & 16  & RD = IM2 \textless\textless{} IM1. Sign-extend IM2 to 64 bits and shift left by the unsigned value IM1. \\
%add           & 1.1   & 17  & RD += IM2 \textless\textless{} IM1. Sign-extend IM2 to 64 bits, shift left by the unsigned value IM1, add to RD. \\
%and           & 1.1   & 18  & RD \&= IM2 \textless\textless{} IM1. Sign-extend IM2 to 64 bits, shift left by the unsigned value IM1, AND with RD. \\
%or            & 1.1   & 19  & RD \textbar{}= IM2 \textless\textless{} IM1. Sign-extend IM2 to 64 bits, shift left by the unsigned value IM1, OR with RD. \\
%xor           & 1.1   & 20  & RD \^{}= IM2 \textless\textless{} IM1. Sign-extend IM2 to 64 bits, shift left by the unsigned value IM1, XOR with RD. \\
%abs           & 1.8   &  0  & Absolute value of integer. Use saturation if IM1 = 1. \\
%shift\_add    & 1.8   &  1  & Shift and add. RD += RS \textless\textless{} IM1 (shift right zero extended if IM1 negative). \\
%read\_spe     & 1.8   & 32  & Read special register RS into g. p. register RD. \\
%write\_spe    & 1.8   & 33  & Write g. p. register RS to special register RD. \\
%read\_cpb     & 1.8   & 34  & Read capabilities register RS into g. p. register RD. \\
%write\_cpb    & 1.8   & 35  & Write g. p. register RS to capabilities register RD. \\
%read\_perf    & 1.8   & 36  & Read performance counter. \\
%read\_perfs   & 1.8   & 37  & Read performance counter, serializing. \\
%read\_sys     & 1.8   & 38  & Read system register RS into g. p. register RD. \\
%write\_sys    & 1.8   & 39  & Write g. p. register RS to system register RD. \\
%load\_hi      & 2.6   &  0  & Load 32-bit constant into the high part of a general purpose register. The low part is zero. RD = IM2 \textless\textless{} 32. \\
%insert\_hi    & 2.6   &  1  & Insert 32-bit constant into the high part of a general purpose register, leaving the low part unchanged.
%RD = (RS \& 0xFFFFFFFF) \textbar{} (IM2 \textless\textless{} 32). \\
%add\_unsigned & 2.6   &  2  & Add zero-extended 32-bit constant to general purpose register. \\
%sub\_unsigned & 2.6   &  3  & Subtract zero-extended 32-bit constant from general purpose register. \\
%add\_hi       & 2.6   &  4  & Add 32-bit constant to high part of general purpose register. RD = RS + (IM2 \textless\textless{} 32). \\
%and\_hi       & 2.6   &  5  & AND high part of general purpose register with 32-bit constant. RD = RS \& (IM2 \textless\textless{} 32). \\
%or\_hi        & 2.6   &  6  & OR high part of general purpose register with 32-bit constant. RD = RS \textbar{} (IM2 \textless\textless{} 32). \\
%xor\_hi       & 2.6   &  7  & XOR high part of general purpose register with 32-bit constant. RD = RS \^{} (IM2 \textless\textless{} 32). \\
%address       & 2.6   & 32  & RD = RS + IM2, RS can be THREADP (28), DATAP (29) or IP (30). \\
%\hline
%\end{longtable}
%
%\begin{longtable} {|p{20mm}|p{10mm}|p{8mm}|p{75mm}|}
%\caption{List of single-format instructions with vector registers and mixed register types} 
%\label{table:ListOfSingleFormatInstructionsVector} \\
%\endfirsthead
%\endhead
%\hline
%\bfseries Instruction & \bfseries Format &\bfseries OP1, OP2 & \bfseries Description \\
%\hline
%set\_len      & 1.2 &  0 & RD = vector register RT with length changed to value of RS. \\
%get\_len      & 1.2 &  1 & Get length of vector register RS into general purpose register RD. \\
%set\_num      & 1.2 &  2 & Change the length of vector register to RS$\cdot$OS. \\
%get\_num      & 1.2 &  3 & Get length of vector register divided by the operand size. \\
%compress      & 1.2 &  4 & Compress vector RT of length RS to a vector of half the length and half the element size. Double precision $\rightarrow$ single precision, 64-bit
%integer $\rightarrow$ 32-bit integer, etc. \\
%compress\_ss  & 1.2 &  5 & Compress integer vector RT of length RS to a vector of half the length and half the element size, signed with saturation (optional). \\
%compress\_us  & 1.2 &  6 & Compress integer vector RT of length RS to a vector of half the length and half element size, unsigned with saturation (optional). \\
%expand        & 1.2 &  7 & Expand vector RT of length RS/2 and half the specified element size to a vector of length RS with the specified element size. Half
%precision $\rightarrow$ single precision, 32-bit integer $\rightarrow$ 64-bit integer with sign extension, etc. \\
%expand\_us    & 1.2 &  8 & Expand integer vector RT of length RS/2 and half the specified element size to a vector of length RS with the specified element
%size. 32-bit integer $\rightarrow$ 64-bit integer with zero extension, etc. \\
%compress\_sparse&1.2 &  9 & Compress sparse vector elements indicated by mask bits into contiguous vector. RS = length of input vector. (optional). \\
%expand\_sparse& 1.2 & 10 & Expand contiguous vector into sparse vector with positions
%indicated by mask bits. RS = length of output vector. (optional). \\
%extract       & 1.2 & 11 & Extract one element from vector RT, starting at offset RS$\cdot$OS, with size OS into scalar in vector register RD. \\
%insert        & 1.2 & 12 & Replace one element in vector RD, starting at offset RS$\cdot$OS, with scalar RT. \\
%broadcast     & 1.2 & 13 & Broadcast first element of vector RT into all elements of RD with length RS. \\
%bits2bool     & 1.2 & 14 & The lower n bits of RT are unpacked into a boolean vector RD with length RS, with one bit in each element, where n = RS / OS. \\
%bool2bits     & 1.2 & 15 & The boolean vector RT with length RS is packed into the lower n bits of RD, taking bit 0 of each element, where n = RS / OS. The
%length of RD is at least sufficient to contain n bits. \\
%bool\_reduce  & 1.2 & 16 & The boolean vector RT with length RS is reduced by combining bit 0 of all elements. The output is a scalar integer where bit 0 is the
%AND combination of all the bits, and bit 1 is the OR combination of
%all the bits. The remaining bits are reserved for future use. \\
%shift\_expand & 1.2 & 18 & Shift vector RT up by RS bytes and extend the vector length by RS. The lower RS bytes of RD will be zero. \\
%shift\_reduce & 1.2 & 19 & Shift vector RT down RS bytes and reduce the length by RS. The lower RS bytes of RT are lost. \\
%shift\_up      & 1.2 & 20 & Shift elements of vector RT up RS elements. The lower RS elements of RD will be zero, the upper RS elements of RT are lost. \\
%shift\_dn      & 1.2 & 21 & Shift elements of vector RT down RS elements. The upper RS
%elements of RD will be zero, the lower RS elements of RT are lost. \\
%div\_ex\_s     & 1.2 & 24 & Divide vector of double-size signed integers RS by signed integers RT. RS has element size 2$\cdot$OS. These are divided by the even numbered
%elements of RT with size OS. The results are stored in
%the even-numbered elements of RD. The remainders are stored in
%the odd-numbered elements of RD. (Optional for vectors). \\
%div\_ex\_u    & 1.2 & 25 & Same, with unsigned integers. (Optional for vectors). \\
%sqrt          & 1.2 & 26 & Square root (floating point, optional). \\
%add\_c        & 1.2 & 28 & Add with carry. Vector has two elements. The upper element is used as carry on input and output (optional). \\
%sub\_b        & 1.2 & 29 & Subtract with borrow. Vector has two elements. The upper element is used as borrow on input and output (optional). \\
%add\_ss       & 1.2 & 30 & Add integer vectors, signed with saturation (optional). \\
%add\_us       & 1.2 & 31 & Add integer vectors, unsigned with saturation (optional). \\
%sub\_ss       & 1.2 & 32 & Subtract integer vectors, signed with saturation (optional). \\
%sub\_us       & 1.2 & 33 & Subtract integer vectors, unsigned with saturation (optional). \\
%mul\_ss       & 1.2 & 34 & Multiply integer vectors, signed with saturation (optional). \\
%mul\_us       & 1.2 & 35 & Multiply integer vectors, unsigned with saturation (optional). \\
%shl\_ss       & 1.2 & 36 & Shift left integer vectors, signed with saturation (optional). \\
%shl\_us       & 1.2 & 37 & Shift left integer vectors, unsigned with saturation (optional). \\
%add\_oc       & 1.2 & 38 & add with overflow check (optional). \\
%sub\_oc       & 1.2 & 39 & subtract with overflow check (optional). \\
%subr\_oc      & 1.2 & 40 & subtract reverse with overflow check (optional). \\
%mul\_oc       & 1.2 & 41 & multiply with overflow check (optional). \\
%div\_oc       & 1.2 & 42 & divide with overflow check (optional). \\
%input         & 1.2 & 48 & read from input port. RD = vector register, RT = port address, RS = vector length (privileged instruction). \\
%output        & 1.2 & 49 & write to output port. RD = vector register source operand, RT = port address, RS = vector length (privileged instruction). \\
%gp2vec        & 1.3 B &  0 & Move value of general purpose register RS to scalar in vector register RD. \\
%set\_bits\_x   & 1.3 B &  1 & Set all bits except one. RD = RS \textbar{} \~{} (1 \textless\textless{} IM1). \\
%clear\_bits\_x & 1.3 B &  2 & Clear all bits except one. RD = RS \& (1 \textless\textless{} IM1). \\
%make\_sequence& 1.3 B &  3 & Make a vector with RS sequential numbers. First value is IM1. \\
%mask\_length  & 1.3 B &  4 & Make mask with true in the first RS bytes. Option bits in IM1. \\
%vec2gp        & 1.3 B &  8 & Move value of first element of vector register RS to general purpose register RD. \\
%bitscan\_f    & 1.3 B &  9 & Bit scan forward. Find index to lowest set bit in RS (optional for vectors). \\
%bitscan\_r    & 1.3 B & 10 & Bit scan reverse. Find index to highest set bit in RS (optional for vectors). \\
%
%float2int     & 1.3 B & 12 & Conversion of floating point to integer with the same operand size. The rounding mode is specified in IM1. \\
%int2float     & 1.3 B & 13 & Conversion of integer to floating point with same operand size. \\
%
%round         & 1.3 B & 14 & Round floating point to integer in floating point  representation. The rounding mode is specified in IM1. \\
%round2n       & 1.3 B & 15 & Round to nearest multiple of $2^n$. \newline 
%RD = $2^n\cdot$ round($2^{-n}\cdot$ RS). $n$ is a signed integer constant in IM1 (optional). \\
%abs           & 1.3 B & 16 & Absolute value of integer. Uses saturation if IM1 = 1. \\
%popcount      & 1.3 B & 17 & Count the number of bits in RS that are 1. \\
%broadcast     & 1.3 B & 18 & Broadcast 8-bit constant into all elements of RD with length RS (31 in RS field gives scalar output). \\
%fp\_category  & 1.3 B & 19 & Check if floating point numbers belong to the categories indicated by constant. \\
%byte\_reverse & 1.3 B & 20 & Reverse the order of bytes in each element of vector. \\
%bit\_reverse  & 1.3 B & 21 & Reverse the order of bits in each element of vector (optional). \\
%truth\_tab2   & 1.3 B & 24 & Boolean function of two inputs, given by a truth table. \\
%read\_spev    & 1.3 B & 30 & Read special register RT into vector register RD with  length RS. \\
%move          & 1.3 C & 32 & Move 16 bit constant to 16-bit scalar (optional). \\
%add           & 1.3 C & 33 & Add broadcast 16 bit constant to 16-bit vector elements (optional). \\
%and           & 1.3 C & 34 & AND broadcast 16 bit constant with 16-bit vector elements (optional). \\
%or            & 1.3 C & 35 & OR broadcast 16 bit constant with 16-bit vector elements (optional). \\
%xor           & 1.3 C & 36 & XOR broadcast 16 bit constant with 16-bit vector elements (optional). \\
%move          & 1.3 C & 38 & RD = IM2 \textless\textless{} IM1. Sign-extend IM2 to 32 bits and shift left by the unsigned value IM1 to make 32 bit scalar (optional). \\
%move          & 1.3 C & 39 & RD = IM2 \textless\textless{} IM1. Sign-extend IM2 to 64 bits and shift left by the unsigned value IM1 to make 64 bit scalar (optional). \\
%add           & 1.3 C & 40 & RD += IM2 \textless\textless{} IM1. Add broadcast shifted signed constant to 32-bit vector elements (optional). \\
%add           & 1.3 C & 41 & RD += IM2 \textless\textless{} IM1. Add broadcast shifted signed constant to 64-bit vector elements (optional). \\
%and           & 1.3 C & 42 & RD \&= IM2 \textless\textless{} IM1. AND broadcast shifted signed constant with 32-bit vector elements (optional). \\
%and           & 1.3 C & 43 & RD \&= IM2 \textless\textless{} IM1. AND broadcast shifted signed constant with 64-bit vector elements (optional). \\
%or            & 1.3 C & 44 & RD \textbar{}= IM2 \textless\textless{} IM1. OR broadcast shifted signed constant with 32-bit vector elements (optional). \\
%or            & 1.3 C & 45 & RD \textbar{}= IM2 \textless\textless{} IM1. OR broadcast shifted signed constant with 64-bit vector elements (optional). \\
%xor           & 1.3 C & 46 & RD \^{}= IM2 \textless\textless{} IM1. XOR broadcast shifted signed constant with 32-bit vector elements (optional). \\
%xor           & 1.3 C & 47 & RD \^{}= IM2 \textless\textless{} IM1. XOR broadcast shifted signed constant with 64-bit vector elements (optional). \\
%add           & 1.3 C & 48 & RD += IM21 \textless\textless{} 16. Add broadcast signed 16-bit constant shifted left by 16 to 32-bit vector elements (optional). \\
%add           & 1.3 C & 49 & RD += IM21 \textless\textless{} 16. Add broadcast signed 16-bit constant shifted left by 16 to 64-bit vector elements (optional). \\
%mov           & 1.3 C & 56 & Move converted half precision floating point constant to single
%precision scalar (optional). \\
%mov           & 1.3 C & 57 & Move converted half precision floating point constant to double
%precision scalar (optional). \\
%add           & 1.3 C & 58 & Add broadcast half precision floating point constant to single
%precision vector (optional). \\
%add           & 1.3 C & 59 & Add broadcast half precision floating point constant to double
%precision vector (optional). \\
%mul           & 1.3 C & 60 & Multiply broadcast half precision floating point constant with single precision vector (optional). \\
%mul           & 1.3 C & 61 & Multiply broadcast half precision floating point constant with double precision vector (optional). \\
%permute       & 2.5 & 2, 8  & The vector elements of RT are permuted within each block of size RS bytes, using indices in RU. Each index is relative to the
%beginning of a block. An index out of range produces zero. The
%maximum block size is implementation dependent. \\
%concatenate   & 2.5 & 2, 9 & A vector RT of length RS and a vector RU of length RS are
%concatenated into a vector RD of length 2$\cdot$RS. \\
%truth\_tab3   & 2.5 & 3, 8 & Boolean function of three inputs, given by a truth table (optional). \\
%truth\_tab4   & 2.5 & 4, 8 & Boolean function of four inputs, given by a truth table (optional). \\
%mul\_add      & 2.5 & 3, 9 & RD = $\pm$ RS $\pm$ RT $\cdot$ RU (optional but recommended). \\
%add\_add      & 2.5 & 3, 10 & RD = $\pm$ RS $\pm$ RT $\pm$ RU (optional). \\
%add\_add\_add & 2.5 & 3, 11 & RD = $\pm$ RS $\pm$ RT $\pm$ RU $\pm$ IM2 
%Add three vector register operands and a 16-bit constant IM2 (optional). \\
%add\_add\_add & 2.5 & 4, 11 & RD = $\pm$ RD $\pm$ RS $\pm$ RT $\pm$ RU
%Add four vector register operands (optional). \\
%load\_hi      & 2.7 & 16 & Make vector of two elements. dest[0] = 0, dest[1] = IM2. \\
%insert\_hi    & 2.7 & 17 & Make vector of two elements. dest[0] = src1[0], dest[1] = IM2. \\
%make\_mask    & 2.7 & 18 & Make vector where bit 0 of each element comes from bits in IM2, the remaining bits come from RS. \\
%replace       & 2.7 & 19 & Replace elements in RS by constant IM2. \\
%replace\_even & 2.7 & 20 & Replace even-numbered elements in RS by constant
%IM2. \\
%replace\_odd  & 2.7 & 21 & Replace odd-numbered elements in RS by constant
%IM2. \\
%broadcast     & 2.7 & 22 & Broadcast 32-bit constant into all elements of RD with length RS (31 in RS field gives scalar output). \\
%permute       & 2.7 & 33 & The vector elements of RT are permuted within each block of size RS bytes. The 4$\cdot$n bits of IM2 are used as index with 4 bits for
%each element in blocks of size n. The same pattern is used in each
%block. The number of elements in each block, n = RS / OS $\leq$ 8. \\
%\hline
%\end{longtable}
%
%\begin{longtable} {|p{20mm}|p{10mm}|p{8mm}|p{75mm}|}
%\caption{List of single-format instructions with memory operands.} 
%\label{table:ListOfSingleFormatInstructionsMemory} \\
%\endfirsthead
%\endhead
%\hline
%\bfseries Instruction & \bfseries Format &\bfseries OP1, OP2 & \bfseries Description \\
%\hline
%store         & 2.7 B & 48 & Store 32-bit constant IM2 to memory operand with base RT and 8-bit offset IM1 (optional). \\
%fence         & 2.4.x & 0, 8 & Memory fence. read, write or full indicated by OP3.  \\
%cmp\_swap     & 2.8.x & 1, 8 & Atomic compare and exchange.  \\
%read\_insert  & 2.4.0 2.4.3 & 2, 8 & Replace one element in vector RD, starting at offset 
%RS$\cdot$OS, with scalar memory operand (optional).  \\
%move\_store   & 2.4.x & 3, 8 & Conditional move and store.\newline
%                               Mask bits = 01 or 11: store RU.\newline 
%                               Mask bits = 10: store zero. \newline
%                               Mask bits = 11: store RD. \newline
%                               (optional). \\
%extract\_store& 2.4.0 & 3, 9 & Extract one element from vector RD, starting at offset RS$\cdot$OS, with size OS into memory operand with base RT and offset IM2 (optional). \\
%extract\_store& 2.4.3 & 3, 9 & Extract one element from vector RD, starting at offset RS$\cdot$OS, with size OS into memory operand with base RT, scaled index RU and unsigned limit RU $\leq$ IM2 (optional). \\
%compress\_store&2.4.1 & 3, 10 & Compress vector RD of length RS to a vector of half the length and half the element size. Double precision $\rightarrow$ single precision, 64-bit integer $\rightarrow$ 32-bit integer, etc. Store at memory with base RT, offset IM2, length RS/2 (optional). \\
%add\_store    & 2.4.x & 4, 8 & Add RD and RU, store the result to memory operand (optional). \\
%sub\_store    & 2.4.x & 4, 9 & Subtract RU from RD, store the result to memory operand (optional). \\
%mul\_store    & 2.4.x & 4, 10 & Multiply RD and RU, store the result to memory operand (optional). \\
%read\_memory\_\newline map  & 2.4.2 & 48, 8 & Read memory map. RD = map entry, RT = memory pointer, RS = vector length and negative index to both source and destination (privileged). \\
%write\_memory\_\newline map & 2.4.2 & 48, 9 & Write memory map. RD = map entry, RT = memory pointer, RS = vector length and negative index to both source and destination (privileged). \\ \hline
%\end{longtable}
\end{document}