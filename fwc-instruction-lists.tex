\documentclass[forwardcom.tex]{subfiles}
\begin{document}

\chapter{Списки команд}
Команды ForwardCom перечислены в файле с разделителями в виде запятых, название которого --- instruction\_list.csv. Этот файл предназначен для использования ассемблерами, дизассемблерами, отладчиками, и эмуляторами. Данный список предварителен, и, возможно, изменится. Пожалуйста, помните, что списки в этом документе синхронизированы со списком в instruction\_list.cvs.

Этот список команд имеет следующие поля:

\begin{longtable} {|p{18mm}|p{130mm}|}\caption{Поля в файле со списком команд} 
\label{table:fieldsInInstructionListFile}
\\
\endfirsthead
\endhead
\hline
\bfseries Поле  & \bfseries Смысл  \\ \hline
Name            & Имя команды, используемое ассемблером.  \\ \hline
Category        & 1: одноформатная команда, \newline
2: малая команда,  \newline
3: многоформатная команда,  \newline
4: команда перехода. \\ \hline
Formats         & См. приводимую ниже табл.~\ref{table:MeaningOfFormatsFieldInInstructionListFile}.  \\ \hline
Template        & Шестнадцатиричное число: \newline
0xA--0xE для шаблонов A--E,  \newline
0x1 для малого шаблона,  \newline
0x0 для множественных шаблонов. \\ \hline

Source operands & Количество операндов--источников, включая регистровые операнды, находящиеся в памяти операнды, и непосредственно заданные операнды, но не включая маску, разряды опций, длину вектора, и индекс. \\ \hline
OP1             & Код операции, OP1. \\ \hline
OP2             & Дополнительный код операции, OP2. Ноль, если нет. \\ \hline
OP3 bits\newline used   & Количество разрядов в поле OP3, используемых для опций. Поле OP3 для счётчика сдвига в форматах 2.5 и 2.9 только если указанное здесь значение равно нулю. \\ \hline
Operand types general purpose registers & Шестнадцатиричное число, указывающее требуемую и необязательную поддержку каждого из типов операндов для регистров общего назначения. По поводу смысла каждого разряда см. приводимую ниже табл.~\ref{table:OperandTypesInInstructionList}. \\ \hline
Operand types scalar & Шестнадцатиричное число, указывающее требуемую и необязательную поддержку каждого из типов операндов для скалярных операций в векторных регистрах. По поводу смысла каждого разряда см. приводимую ниже табл.~\ref{table:OperandTypesInInstructionList}. \\ \hline
Operand types vector & Шестнадцатиричное число, указывающее требуемую и необязательную поддержку каждого из типов операндов для векторных операций. По поводу смысла каждого разряда см. приводимую ниже табл.~\ref{table:OperandTypesInInstructionList}. \\ \hline
Immediate operand type & Тип непосредственно заданного операнда для одноформатных команд. См. приводимую ниже табл.~\ref{table:immediateOperantTypesInInstructionList}. \\ \hline
Description & Описания команды и комментарии. \\ \hline
\end{longtable}

\pagebreak % The text in the multirow box below disappears if there is a page break in it. 
% Put page break here instead to prevent this
\label{table-format-field-in-list}
\begin{longtable} {|p{26mm}|p{16mm} p{100mm}|}
\caption{Смысл полей формата в файле со списком команд} \label{table:MeaningOfFormatsFieldInInstructionListFile}\\
\endfirsthead
\endhead
\hline
\bfseries Категория & \multicolumn{2}{|l|}{\bfseries Интерпретация полей форматов} \\
\hline
1.  Одноформатная команда. & \multicolumn{2}{|p{120mm}|}{
Число из трёх шестнадцатиричных цифр. Крайняя левая цифра --- значение поля IL (0-3). 
Средняя цифра --- значение поля Mode, или комбинированного поля M+Mode (0-9).
Крайняя правая цифра --- подрежим, определяемый полем OP3 в форматах 2.4.x и 2.8.x, или OP1 в формате 2.7.x. Иначе нуль. 
Например, 0x283 означает формат 2.8.3.
}  \\ \hline
\multirow{11}{*}{\parbox{26mm}{2. Малая команда}} 
&  0 & Нет операндов. \\
&  1 & RD = операнд--приёмник, являющийся регистром общего назначения, RS = непосредственно заданный операнд. \\
&  2 & RD = операнд--приёмник, являющийся РОН\footnote{Регистр общего назначения}, RS = регистр источник, являющийся РОН. \\
&  4 & RD = операнд--приёмник, являющийся РОН, RS = указатель на находящийся в памяти операнд--источник. \\
&  5 & RD = операнд--источник, являющийся РОН, RS = указатель на находящийся в памяти операнд--приёмник. \\
&  8 & RD = операнд--приёмник, являющийся векторным регистром, RS --- неиспользуется. \\
&  9 & RD = операнд--приёмник, являющийся векторным регистром, RS --- непосредственно заданный операнд. \\
& 10 & RD = операнд--приёмник, являющийся векторным регистром, RS --- являющий векторным регистром источник. \\
& 11 & RD = операнд--источник, являющийся вектоным регистром, RS --- являющийся приёмником РОН r0-r14,r31. \\
& 12 & RD = операнд--приёмник, являющийся векторным регистром, RS = указатель на находящийся в памяти операнд--источник. \\
& 13 & RD = операнд--источник, являющийся вектоным регистром, RS = указатель на находящийся в памяти операнд--приёмник. \\ \hline
%	% \pagebreak % The text in the multirow box disappears if there is a page break in it. 
%	% Put pagebreak here to prevent this, or before the table
%	% \hline
\multirow{27}{*}{\parbox[t]{26mm}{3. Многоформатная команда}} 
	&  \multicolumn{2}{|p{120mm}|}{Шестнадцатиричное число, составленное из разрядов, каждый из которых отвечает за поддержку своего формата:} \\
	&  0x0000001 & Формат 0.0: три регистра общего назначения. \\
	&  0x0000002 & Формат 0.1: два регистра общего назначения и 8--разрядное непосредственно заданное значение. \\
	&  0x0000004 & Формат 0.2: три векторных регистра. \\
	&  0x0000008 & Формат 0.3: два векторных регистра и 8--разрядное непосредственно заданное значение. \\
	&  0x0000010 & Формат 0.4: один вектор и находящийся в памяти операнд. \\
	&  0x0000020 & Формат 0.5: один вектор и находящийся в памяти операнд с отрицательным индексом. \\
	&  0x0000040 & Формат 0.6: один вектор и находящийся в памяти скалярный операнд с индексом. \\
	&  0x0000080 & Формат 0.7: один вектор и находящийся в памяти скалярный операнд с 8--разрядным смещением. \\
	&  0x0000100 & Формат 0.8: один РОН и находящийся в памяти операнд с индексом. \\
	&  0x0000200 & Формат 0.9: один РОН и находящийся в памяти операнд с 8--разрядным смещением. \\
	&  0x0000400 & Формат 2.0: два РОН и находящийся в памяти операнд с 32--разрядным смещением. \\
	&  0x0000800 & Формат 2.1: три РОН и 32--разрядное непосредственно заданное значение. \\
	&  0x0001000 & Формат 2.2: один векторный регистр и находящийся в памяти операнд с 32--разрядным смещением. \\
	&  0x0002000 & Формат 2.3: три векторных регистра и 32--разрядное непосредственно заданное значение. \\
	&  0x0004000 & Формат 2.4.0: два векторных регистра и находящийся в памяти скалярный операнд с 16--разрядным смещением. \\
	&  0x0008000 & Формат 2.4.1: два векторных регистра и находящийся в памяти операнд с 16--разрядным смещением. \\
	&  0x0010000 & Формат 2.4.2: два векторных регистра и находящийся в памяти операнд с отрицательным индексом. \\
	&  0x0020000 & Формат 2.4.3: два векторных регистра и находящийся в памяти скалярный операнд с индексом и лимитом. \\
	&  0x0040000 & Формат 2.5: три векторных регистра и сдвинутое 16--разрядное непосредственно заданное значение. \\
	&  0x0080000 & Формат 2.8.0: три РОН и находящийся в памяти операнд с 16--разрядным смещением. \\
	&  0x0100000 & Формат 2.8.1: два РОН и находящийся в памяти операнд с немасштабируемым индексом. \\
	&  0x0200000 & Формат 2.8.2: два РОН и находящийся в памяти операнд с масштабируемым индексом. \\
	&  0x0400000 & Формат 2.8.3: два РОН и находящийся в памяти скалярный операнд с индексом и лимитом. \\
	&  0x0800000 & Формат 2.9: три РОН и сдвинутое 16--разрядное непосредственно заданное значение. \\
	&  0x1000000 & Формат 3.1: три РОН и 64--разрядное непосредственно заданное значение (необязательно). \\
	&  0x2000000 & Формат 3.3: три векторных регистра и 64--разрядное непосредственно заданное значение (необязательно). \\ 	\hline
	\multirow{12}{*}{\parbox[t]{26mm}{4. Команда перехода}} 
	&  \multicolumn{2}{|p{120mm}|}{Шестнадцатиричное число, составленное из разрядов, каждый из которых отвечает за поддержку своего формата:} \\
	&  0x001 & Формат 1.4: два регистра и 8--разрядное смещение. \\
	&  0x002 & Формат 1.5 C: один регистр, 8--разрядное непосредственно заданное значение, и 8--разрядное смещение. \\
	&  0x004 & Формат 1.5 C: 16--разрядное смещение. \\
	&  0x008 & Формат 1.5 D: нет регистра, но есть 24--разрядное смещение. \\
	&  0x010 & Формат 2.7.0: два регистра и 32--разрядное смещение. \\
	&  0x020 & Формат 2.7.1: два регистра, 16--разрядное непосредственно заданное значение, и 16--разрядное смещение. \\
	&  0x040 & Формат 2.7.2: один регистр, 8--разрядное непосредственно заданное значение, и 32--разрядное смещение. \\
	&  0x080 & Формат 2.7.3: один регистр, 32--разрядное непосредственно заданное значение, и 8--разрядное смещение. \\
	&  0x100 & Формат 2.7.4: системный вызов, 16--разрядный ID фунции и 32--разрядный ID модуля. \\
	&  0x200 & Формат 3.0.1: два регистра, 32--разрядное непосредственно заданное значение, и 32--разрядное смещение. \\
	&  0x400 & Формат 3.0.1: 64--разрядный абсолютный адрес. \\ 	\hline
\end{longtable}

\begin{longtable} {|p{18mm}|p{100mm}|}
\caption{Указание типов операндов, поддерживаемых регистрами общего назначения, скалярами в векторных регистрах, или векторами. Данное значение представляет собой шестнадцатиричное число, составленное из разрядов, каждый из которых отвечает за поддержку своего формата} 
\label{table:OperandTypesInInstructionList} \\
\endfirsthead
\endhead
\hline
0x0001 & поддержка 8--разрядных целых                                        \\ 	\hline
0x0002 & поддержка 16--разрядных целых                                       \\ 	\hline
0x0004 & поддержка 32--разрядных целых                                       \\ 	\hline
0x0008 & поддерка 64--разрядных целых                                        \\ 	\hline
0x0010 & поддержка 128--разрядных целых                                      \\ 	\hline
0x0020 & поддержка вещественных чисел одинарной точности                     \\ 	\hline
0x0040 & поддержка вещественных чисел двойной точности                       \\ 	\hline
0x0080 & поддержка вещественных чисел четырёхкратной точности                \\ 	\hline
0x0100 & необязательная поддержка 8--разрядных целых                         \\ 	\hline
0x0200 & необязательная поддержка 16--разрядных целых                        \\ 	\hline
0x0400 & необязательная поддержка 32--разрядных целых                        \\ 	\hline
0x0800 & необязательная поддержка 64--разрядных целых                        \\ 	\hline
0x1000 & необязательная поддержка 128--разрядных целых                       \\ 	\hline
0x2000 & необязательная поддержка вещественных чисел одинарной точности      \\ 	\hline
0x4000 & необязательная поддержка вещественных чисел двойной точности        \\ 	\hline
0x8000 & необязательная поддержка вещественных чисел четырёхкратной точности \\ 	\hline
\end{longtable}

\begin{longtable} {|l|p{140mm}|}
\caption{Тип непосредственно заданного заданного операнда для одноформатных команд} 
\label{table:immediateOperantTypesInInstructionList}
\\
\endfirsthead
\endhead
\hline
0  & нет аргументов или многоформатная команда \\
1  & 4--разрядное знаковое целое число \\
2  & 8--разрядное знаковое целое число \\
3  & 16--разрядное знаковое целое число \\
4  & 32--разрядное знаковое целое число \\
5  & 64--разрядное знаковое целое число \\
6  & 8--разрядное знаковое целое число, сдвигаемое на указанное количество разрядов \\
7  & 16--разрядное знаковое целое число, сдвигаемое на указанное количество разрядов \\
8  & 16--разрядное знаковое целое число, сдвигаемое на 16 разрядов \\
9  & 32--разрядное знаковое целое число, сдвигаемое на 32 разрядов \\
17 & 4--разрядное беззнаковое целое число \\
18 & 8--разрядное беззнаковое целое число \\
19 & 16--разрядное беззнаковое целое число \\
20 & 32--разрядное беззнаковое целое число \\
21 & 64--разрядное беззнаковое целое число \\
33 & 4--разрядное знаковое целое число, преобразуемое в вещественное число \\
34 & 8--разрядное знаковое целое число, преобразуемое в вещественное число \\
35 & 16--разрядное знаковое целое число, преобразуемое в вещественное число \\
39 & 16--разрядное знаковое целое число, сдвигаемое на указанное количество разрядов, и преобразуемое затем в вещественное число \\
64 & вещественное число половинной точности \\
65 & вещественное число одинарной точности \\
66 & вещественное число двойной точности \\ \hline
\end{longtable}

Команды перехода перечислены на с.~\pageref{table:controlTransferInstructions}. Все прочие категории команд перечислены в последующих таблицах.

\section{Список многоформатных команд}
Следующий список команд охватывает общепринятые команды, которые можно закодировать в большинстве форматов или во всех форматах, предназначенных для многоформатных команд.

\begin{longtable} {|p{18mm}|p{9mm}|p{21mm}|p{95mm}|}
\caption{Список многоформатных команд} 
\label{table:ListOfMultiFormatInstructions} \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries OP1 & \bfseries Операндов--источников & \bfseries Описание            \\ \hline
nop               &  0           & 0                                & Нет операции.                 \\
move              &  1           & 1                                & Копирование значения.         \\
store             &  2           & 1                                & Сохранение значения в памяти. \\
prefetch          &  3           & 1                                & Предвыборка из памяти.        \\
sign\_extend      &  4           & 1                                & Расширить меньшее целое знаком до 64 разрядов. \\
add               &  8           & 2                                & src1 + src2. \\
sub               &  9           & 2                                & src1 - src2. \\
sub\_r            & 10           & 2                                & src2 - src1. \\
compare           & 11           & 2                                & Сравнение. Использует коды условий, см. с.~\pageref{table:conditionCodesForCompareInstruction}. \\
mul               & 12           & 2                                & src1 $\cdot$ src2. \\ 
mul\_hi\_s        & 13           & 2                                & (src1 $\cdot$ src2) $\gg$ OS, знаково (только для целых чисел). \\
mul\_hi\_u        & 14           & 2                                & (src1 $\cdot$ src2) $\gg$  OS, беззнаково (только для целых чисел). \\
mul\_ex\_s        & 15           & 2                                & Перемножить элементы с чётными номерами векторов, состоящих из знаковых целых чисел, для получения результатов двойного размера. \\
mul\_ex\_u        & 16           & 2                                & Перемножить элементы с чётными номерами векторов, состоящих из беззнаковых целых чисел, для получения результатов двойного размера. \\
div               & 17           & 2                                & src1 / src2 (необязательно для целочисленных векторов). \\
rem               & 18           & 2                                & Остаток от деления (необязательно для целочисленных векторов). \\
min               & 20           & 2                                & Знаковый минимум. \\
max               & 21           & 2                                & Знаковый максимум. \\
min\_u            & 22           & 2                                & Беззнаковый минимум для целых чисел, минимум из абсолютных величин для вещественных. \\
max\_u            & 23           & 2                                & Беззнаковый максимум для целых чисел, максимум из абсолютных величин для вещественных. \\
and               & 32           & 2                                & src1 \& src2. \\
and\_not          & 33           & 2                                & src1 \& (\~{}src2). \\
or                & 34           & 2                                & src1 \textbar{} src2. \\
xor               & 35           & 2                                & src1 \^{} src2. \\
shift\_left       & 36           & 2                                & src1 $\ll$  src2.  \\
shift\_rightu     & 37           & 2                                & src1 $\gg$ src2, с расширением нулём. \\
shift\_rights     & 38           & 2                                & src1 $\gg$ src2, с расширением знаком. \\
rotate            & 39           & 2                                & Вращать влево, если src2 положительно, и вправо --- если отрицательно. \\
extract\_bit      & 40           & 2                                & Выделить разряд. (src1 $\gg$ src2) \& 1. \\
set\_bit          & 41           & 2                                & Установить разряд. src1 \textbar{} (1 $\ll$ src2). \\
clear\_bit        & 42           & 2                                & Сбросить разряд. src1 \& \~{} (1 $\ll$ src2). \\
toggle\_bit       & 43           & 2                                & Инвертировать разряд. src1 \^{} (1 $\ll$ src2). \\
mul\_add          & 46           & 3                                & $\pm \text{src1} \pm \text{src2} \cdot \text{src3}$ (необязательно). \\
add\_add          & 47           & 3                                & $\pm \text{src1} \pm \text{src2} \pm \text{src3}$ (необязательно). \\
userdef55 -- userdef62 & 55-62 & 2 & Зарезервировано для определяемых пользователем команд. \\
undef             & 63           & 2                                & Неопределённый код. Гарантированно возбуждает прерывание (trap)  во всех будущих реализациях. \\ \hline
\end{longtable}

\section{Список малых команд}
В одном 32--разрядном слове кода помещается две малых команды. Если малая команда не может спариваться ни с чем иным, то она спаривается с малой nop.

Если не оговорено иное, то операнды малых команд --- 64--разрядные. RD --- регистр--приёмник, и, в большинстве случаев, также и первый из регистров--источников. RS может быть одним из регистров r0-r15, v0-v15, либо непосредственно заданной расширенной знаком 4--разрядной константой. Команды с указателем в RS используют в качестве указателя r0-r14, когда RS --- от 0 до 14, и указатель стека (r31), когда RS равно 15.

Поскольку адрес команды должен быть кратен четырём, то невозможно перейти на вторую команду из пары малых команд. Если прерывание или ловушка возникли при выполнении малой команды, то обработчик прерывания должен запомнить, какая из двух малых команд была прервана.

\begin{longtable} {|p{20mm}|p{8mm}|p{100mm}|}
\caption{Список малых команд, работающих с регистрами общего назначения} 
\label{table:tinyInstructionsGP} \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries OP1 & \bfseries Описание \\ \hline
nop               &  0            & Нет операции. \\
move              &  1            & RD = расширенная знаком константа из поля RS. \\
add               &  2            & RD += расширенная знаком константа из поля RS. \\
sub               &  3            & RD --= расширенная знаком константа из поля RS. \\
shift\_left       &  4            & RD $\ll$= беззнаковая константа из поля RS. \\
shift\_rightu     &  5            & RD $\gg$= беззнаковая константа из поля RS (расширение нулём). \\
move              &  8            & RD = регистровый операнд RS. \\
add               &  9            & RD += регистровый операнд RS. \\
sub               & 10            & RD --= регистровый операнд RS. \\
and               & 11            & RD \&= регистровый операнд RS. \\
or                & 12            & RD \textbar= регистровый операнд RS. \\
xor               & 13            & RD \^{}= регистровый операнд RS. \\
move              & 14            & Прочесть RD из находящегося в памяти операнда, имеющего заданный полем RS  (RS = r0-r14, r31) указатель. \\
store             & 15            & Записать RD в находящийся в памяти операнд, имеющий заданный полем RS  (RS = r0-r14, r31) указатель. \\ \hline
\end{longtable}

\begin{longtable} {|p{20mm}|p{8mm}|p{100mm}|}
\caption{Список малых команд, работающих с векторными регистрами}
\label{table:tinyInstructionsVector}  \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries OP1 & \bfseries Описание                                                                     \\ \hline
clear             & 16            & Очистить регистр RD, установив его длину равной нулю.                                  \\
move              & 17            & RD = знаковое 4--разрядное целое из RS, преобразованное в скаляр одинарной точности.   \\
move              & 18            & RD = знаковое 4--разрядное целое из RS, преобразованное в скаляр двойной точности.     \\
move              & 19            & RD = RS. Копировать вектор любого типа.                                                \\
add               & 20            & RD += RS, вектор из вещественных чисел одинарной точности.                             \\
add               & 21            & RD += RS, вектор из вещественных чисел двойной точности.                               \\
sub               & 22            & RD --= RS, вектор из вещественных чисел одинарной точности.                            \\
sub               & 23            & RD --= RS, вектор из вещественных чисел двойной точности.                              \\
mul               & 24            & RD *= RS,вектор из вещественных чисел одинарной точности.                              \\
mul               & 25            & RD *= RS, вектор из вещественных чисел двойной точности.                               \\
add\_cps          & 28            & Получить размер сжатого образа для RD и прибавить его к регистру общего назначения RS. \\
sub\_cps          & 29            & Получить размер сжатого образа для RD и вычесть его из регистра общего назначения RS.  \\
restore\_cp       & 30            & Восстановить векторный регистр RD из сжатого образа, на который указывает RS.          \\
save\_cp          & 31            & Сохранить векторный регистр RD в сжатый образ, на который указывает RS.                \\ \hline
\end{longtable}

\section{Список одноформатных команд}
Эти команды имеются преимущественно в одном или нескольких форматах.

\begin{longtable} {|p{23mm}|p{15mm}|p{9mm}|p{99mm}|}
\caption{Список одноформатных команд, работающих с регистрами общего назначения} 
\label{table:ListOfSingleFormatInstructionsGP} \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries Формат &\bfseries OP1 & \bfseries Описание \\ \hline
bitscan\_f        & 1.0   &  1 & Сканировать разряды вперёд. Найти номер самого младшего разряда RS, равного единице (необязательна). \\
bitscan\_r        & 1.0   &  2 & Сканировать разряды назад. Найти номер самого старшего разряда RS, равного единице (необязательна).  \\
round\_d2         & 1.0   &  3 & Округлить RS к ближайшей меньшей степени числа 2.                                                    \\
round\_u2         & 1.0   &  4 & Округлить RS к ближайшей большей степени числа 2.                                                    \\
move              & 1.1   &  0 & Переслать 16--разрядную расширенную знаком константу в регистр общего назначения RD.                 \\
move\_u           & 1.1   &  1 & Переслать 16--разрядную расширенную нулём константу в регистр общего назначения RD (может использоваться в качестве первого шага загрузки 32--разрядной константы, если не поддерживаются команды двойного размера). \\
add               & 1.1   &  2 & Прибавить 16--разрядную расширенную знаком константу к RD. \\
sub               & 1.1   &  3 & Вычесть 16--разрядную расширенную знаком константу из RD.  \\
subr              & 1.1   &  4 & Вычесть RD из 16--разрядной расширенной знаком константы.  \\
mul               & 1.1   &  5 & Умножить RD на 16--разрядную расширенную знаком константу. \\
div               & 1.1   &  6 & Поделить RD на 16--разрядную расширенную знаком константу. \\
add               & 1.1   &  7 & Сдвинуть  16--разрядную расширенную знаком константу влево на 16 разрядов и прибавить к RD. \\
move              & 1.1   & 16 & RD = IM2 $\ll$ IM1. Знаково расширить IM2 до 64 разрядов и сдвинуть результат влево, на количество разрядов, указанное беззнаковым значением в IM1. \\
add               & 1.1   & 17 & RD += IM2 $\ll$ IM1. Знаково расширить IM2 до 64 разрядов, сдвинуть результат влево, на количество разрядов, указанное беззнаковым значением в IM1, и прибавить то, что получилось, к RD. \\
and               & 1.1   & 18 & RD \&= IM2 $\ll$ IM1. Знаково расширить IM2 до 64 разрядов, сдвинуть результат влево, на количество разрядов, указанное беззнаковым значением в IM1, и выполнить поразрядное И с RD. \\
or                & 1.1   & 19 & RD \textbar{}= IM2 $\ll$ IM1. Знаково расширить IM2 до 64 разрядов, сдвинуть результат влево, на количество разрядов, указанное беззнаковым значением в IM1, и выполнить поразрядное ИЛИ с RD. \\
xor               & 1.1   & 20 & RD \^{}= IM2 $\ll$. Знаково расширить IM2 до 64 разрядов, сдвинуть результат влево, на количество разрядов, указанное беззнаковым значением в IM1, и выполнить поразрядное ИСКЛЮЧАЮЩЕЕ ИЛИ с RD. \\
abs               & 1.8   &  0 & Абсолютная величина целого числа. Использовать насыщение, если IM1 = 1. \\
shift\_add        & 1.8   &  1 & Сдвинуть и сложить. RD += RS $\ll$ IM1 (сдвинуть вправо, расширив нулём, если IM1 отрицательно). \\
read\_spe         & 1.8   & 32 & Прочитать содержимое специального регистра RS в РОН RD. \\
write\_spe        & 1.8   & 33 & Записать содержимое РОН RS в специальный регистр RD. \\
read\_cpb         & 1.8   & 34 & Прочитать содержимое регистра возможностей RS в РОН RD. \\
write\_cpb        & 1.8   & 35 & Записать содержимое РОН RS в регистр возможностей RD. \\
read\_perf        & 1.8   & 36 & Прочесть счётчик производительности. \\
read\_perfs       & 1.8   & 37 & Прочесть счётчик производительности, используя сериализацию. \\
read\_sys         & 1.8   & 38 & Прочесть содержимое системного регистра RS в РОН RD. \\
write\_sys        & 1.8   & 39 & Записать содержимое РОН RS в системный регистр RD. \\
load\_hi          & 2.6   &  0 & Загрузить 32--разрядную константу в старшую часть регистра общего назначения. Младшая часть зануляется. RD = IM2 $\ll$ 32. \\
insert\_hi        & 2.6   &  1 & Вставить 32--разрядную константу в старшую часть регистра общего назначения, оставляя младшую часть без изменения. RD = (RS \& 0xFFFFFFFF) \textbar{} (IM2 $\ll$ 32). \\
add\_unsigned     & 2.6   &  2 & Прибавить расширенную нулём 32--разрядную константу к регистру общего назначения. \\
sub\_unsigned     & 2.6   &  3 & Вычесть расширенную нулём 32--разрядную константу из регистра общего назначения. \\
add\_hi           & 2.6   &  4 & Прибавить 32--разрядную константу к старшей части регистра общего назначения. RD = RS + (IM2 $\ll$ 32). \\
and\_hi           & 2.6   &  5 & Поразрядное И старшей части регистра общего назначения с 32--разрядной константой. RD = RS \& (IM2 $\ll$ 32). \\
or\_hi            & 2.6   &  6 & Поразрядное ИЛИ старшей части регистра общего назначения с 32--разрядной константой. RD = RS \textbar{} (IM2 $\ll$ 32). \\
xor\_hi           & 2.6   &  7 & Поразрядное ИСКЛЮЧАЮЩЕЕ ИЛИ старшей части регистра общего назначения с 32--разрядной константой. RD = RS \^{} (IM2 $\ll$ 32). \\
address           & 2.6   & 32 & RD = RS + IM2, RS может быть THREADP (28), DATAP (29), или IP (30). \\ \hline
\end{longtable}

\begin{longtable}{|p{25mm}|p{16mm}|p{9mm}|p{99mm}|}
\caption{Список одноформатных команд, работающих с векторными регистрами и регистрами разного типа} 
\label{table:ListOfSingleFormatInstructionsVector} \\
\endfirsthead
\endhead
\hline
\bfseries Команда & \bfseries Формат &\bfseries OP1, OP2 & \bfseries Описание \\ \hline
set\_len         & 1.2 &  0 & RD = векторный регистр RT со значением длины, указанным в RS. \\
get\_len         & 1.2 &  1 & Записать длину векторного регистра RS в регистр общего назначения RD. \\
set\_num         & 1.2 &  2 & Заменить длину векторного регистра на RS$\cdot$OS. \\
get\_num         & 1.2 &  3 & Получить длину векторного регистра, делённую на размер операнда. \\
compress         & 1.2 &  4 & Сжать вектор RT длины RS до вектора половинной длины и половинного размера элемента: двойная точность $\rightarrow$ одинарная точность, 64--разрядное целое $\rightarrow$ 32--разрядное целое, и т.п. \\
compress\_ss     & 1.2 &  5 & Сжать целочисленный вектор RT длины RS до вектора половинной длины и половинного размера элемента, знаково и с насыщением (необязательна). \\
compress\_us     & 1.2 &  6 & Сжать целочисленный вектор RT длины RS до вектора половинной длины и половинного размера элемента, беззнаково и с насыщением (необязательна). \\
expand           & 1.2 &  7 & Расширить вектор RT длины RS/2 и половинного размера элемента до вектора длины RS с полного размера элемента: половинная точность $\rightarrow$ одинарная точность, 32--разрядное целое $\rightarrow$ 64--разрядное целое (с расширением знаком), и т.п. \\
expand\_us       & 1.2 &  8 & Расширить вектор RT длины RS/2 и половинного размера элемента до вектора длины RS с полного размера элемента: 32--разрядное целое $\rightarrow$ 64--разрядное целое (с расширением нулём), и т.п. \\
compress\_sparse & 1.2 &  9 & Сжать разреженный вектор с элементами, указанными разрядами маски, в непрерывный вектор. RS = длина входного вектора (необязательна). \\
expand\_sparse   & 1.2 & 10 & Расширить непрерывный вектор до разреженного вектора, позиции в котором указаны разрядами маски. RS = длина результирующего вектора (необязательна). \\
extract          & 1.2 & 11 & Выделить один элемент из вектора RT, начинающийся со смещения RS$\cdot$OS и имеющий размер OS, в скаляр, находящийся в векторном регистре RD. \\
insert           & 1.2 & 12 & Заменить один элемент вектора RD, начинающийся со смещения RS$\cdot$OS, скаляром из RT. \\
broadcast        & 1.2 & 13 & Разослать первый элемент вектора RT во все элементы вектора RD, имеющего длину, указанную в RS. \\
bits2bool        & 1.2 & 14 & Младшие n разрядов из RT распаковываются в булев вектор RD длины RS, с одним разрядом в каждом элементе, где n = RS / OS. \\
bool2bits        & 1.2 & 15 & Булев вектор RT длины RS упаковывается в младшие n разрядов RD, беря разряд с номером 0 в каждом элементе, n = RS / OS. Длина RD должна быть достаточна для хранения, по меньшей мере, n разрядов. \\
bool\_reduce     & 1.2 & 16 & Логический вектор RT длины RS сворачивается, посредством комбинирования разрядов номер 0 всех элементов. Результатом является скалярное целое, в котором разряд №0 является поразрядным И всех разрядов с номером 0, а разряд №1 --- поразрядными ИЛИ. Остальные разряды зарезервированы для последующего использования. \\
shift\_expand    & 1.2 & 18 & Сдвинуть вектор RT влево на RS байтов и увеличить длину вектора на RS. Младшие RS байтов в RD будут нулями. \\
shift\_reduce    & 1.2 & 19 & Сдвинуть вектор RT вправо на RS байтов и уменьшить длину вектора на RS. Младшие RS байт вектора RT теряются. \\
shift\_up        & 1.2 & 20 & Сдвинуть вектор RT влево на RS элементов. Младшие RS элементов вектора RD будут нулями, а старшие RS элементов из RT --- теряются. \\
shift\_dn        & 1.2 & 21 & Сдвинуть вектор RT вправо на RS элементов. Старшие RS элементов вектора RD будут нулями, а младшие RS элементов из RT --- теряются. \\
div\_ex\_s       & 1.2 & 24 & Разделить вектор RS, состоящий из целых чисел двойного размера, на знаковые целые числа из RT. Размер элемента RS равен 2$\cdot$OS. Деление выполняется на элементы вектора RT (размер элемента которого равен OS), имеющие чётные номера. Частные сохраняются в элементах вектора RD, имеющих чётные номера, а остатки --- в элементах с нечётными номерами (для векторов --- необязательно). \\
div\_ex\_u       & 1.2 & 25 & То же, но для беззнаковых целых (для векторов --- необязательно). \\
sqrt             & 1.2 & 26 & Квадратный корень (для вещественных чисел, необязательно). \\
add\_c           & 1.2 & 28 & Сложить с переносом. Вектор имеет два элемента.  Старший элемент используется как перенос и на входе, и на выходе (необязательна). \\
sub\_b           & 1.2 & 29 & Вычесть с заёмом. Вектор имеет два элемента.  Старший элемент используется как заём и на входе, и на выходе (необязательна). \\
add\_ss          & 1.2 & 30 & Сложить целочисленные векторы, со знаковым насыщением (необязательна). \\
add\_us          & 1.2 & 31 & Сложить целочисленные векторы, с беззнаковым насыщением (необязательна). \\
sub\_ss          & 1.2 & 32 & Вычесть целочисленные векторы, со знаковым насыщением (необязательна). \\
sub\_us          & 1.2 & 33 & Вычесть целочисленные векторы, с беззнаковым насыщением (необязательна). \\
mul\_ss          & 1.2 & 34 & Умножить целочисленные векторы, со знаковым насыщением (необязательна). \\
mul\_us          & 1.2 & 35 & Умножить целочисленные векторы, с беззнаковым насыщением (необязательна). \\
shl\_ss          & 1.2 & 36 & Сдвинуть влево целочисленные векторы, со знаковым насыщением (необязательна). \\
shl\_us          & 1.2 & 37 & Сдвинуть влево целочисленные векторы, с беззнаковым насыщением (необязательна). \\
add\_oc          & 1.2 & 38 & Сложить с проверкой переполнения (необязательна). \\
sub\_oc          & 1.2 & 39 & Вычесть с проверкой переполнения (необязательна). \\
subr\_oc         & 1.2 & 40 & Обратное вычитание с проверкой переполнения (необязательна). \\
mul\_oc          & 1.2 & 41 & Умножить с проверкой переполнения (необязательна). \\
div\_oc          & 1.2 & 42 & Деление с проверкой переполнения (необязательна). \\
input            & 1.2 & 48 & Прочесть из порта ввода. RD = векторный регистр, RT = адрес порта, RS = длина вектора (привилегированная команда). \\
output           & 1.2 & 49 & Записать в порт вывода. RD = являющийся векторным регистром операнд--источник, RT = адрес порта, RS = длина вектора (привилегированная команда). \\
gp2vec           & 1.3 B &  0 & Переслать значение из регистра общего назначения RS в находящийся в векторном регистре RD скаляр. \\
set\_bits\_x     & 1.3 B &  1 & Установить все разряды, кроме одного. RD = RS \textbar{} \~{} (1 $\ll$ IM1). \\
clear\_bits\_x   & 1.3 B &  2 & Сбросить все разряды, кроме одного. RD = RS \& (1 $\ll$ IM1). \\
make\_sequence   & 1.3 B &  3 & Создать вектор, состоящий из RS последовательных чисел. Первое значение равно IM1. \\
mask\_length     & 1.3 B &  4 & Создать маску с true в первых RS байтах. Разряды опций --- в IM1. \\
vec2gp           & 1.3 B &  8 & Переслать значение первого элемента векторного регистра RS в регистр общего назначения RD. \\
bitscan\_f       & 1.3 B &  9 & Сканировать разряды вперёд. Найти индекс самого младшего разряда регистра RS, равного единице (для векторов необязательна). \\
bitscan\_r       & 1.3 B & 10 & Сканировать разряды назад. Найти индекс самого старшего разряда регистра RS, равного единице (для векторов необязательна). \\
float2int        & 1.3 B & 12 & Преобразование вещественного значения в целочисленное значение, имеющее тот же размер операнда. Режим округления указывается в IM1. \\
int2float        & 1.3 B & 13 & Преобразование целочисленного значения в вещественное значение, имеющее тот же размер операнда. \\
round            & 1.3 B & 14 & Округлить вещественное число к целочисленному значению в вещественном представлении. Режим округления указывается в IM1. \\
round2n          & 1.3 B & 15 & Округлить к ближайшему кратному числа $2^n$. \newline 
     RD = $2^n\cdot$ round($2^{-n}\cdot$ RS). $n$ --- знаковая целочисленная константа, находящаяся в IM1 (необязательна). \\
abs              & 1.3 B & 16 & Абсолютная величина целого числа. Если IM1 = 1, то используется насыщение. \\
popcount         & 1.3 B & 17 & Подсчитать количество разрядов регистра RS, равных 1. \\
broadcast        & 1.3 B & 18 & Разослать 8--разрядную константу во все элементы регистра RD, имеющего длину, указанную в регистре RS (31 в поле RS даёт скалярный результат). \\
fp\_category     & 1.3 B & 19 & Проверить, принадлежат ли вещественные числа категориям, указанным  константой. \\
byte\_reverse    & 1.3 B & 20 & Обратить порядок байтов в каждом элементе вектора. \\
bit\_reverse     & 1.3 B & 21 & Обратить порядок разрядов в каждом элементе вектора (необязательна). \\
truth\_tab2      & 1.3 B & 24 & Булева функция от двух переменных, заданная таблицей истинности. \\
read\_spev       & 1.3 B & 30 & Прочесть специальный регистр RT в векторный регистр RD, имеющий длину RS. \\
move             & 1.3 C & 32 & Переслать 16--разрядную константу в 16--разрядный скаляр (необязательна). \\
add              & 1.3 C & 33 & Сложить размноженную 16--разрядную константу с 16--разрядными элементами вектора (необязательна). \\
and              & 1.3 C & 34 & Выполнить поразрядное И размноженной 16--разрядной константы с 16--разрядными элементами вектора (необязательна). \\
or               & 1.3 C & 35 & Выполнить поразрядное ИЛИ размноженной 16--разрядной константы с 16--разрядными элементами вектора (необязательна).  \\
xor              & 1.3 C & 36 & Выполнить поразрядное ИСКЛЮЧАЮЩЕЕ ИЛИ размноженной 16--разрядной константы с 16--разрядными элементами вектора (необязательна). \\
move             & 1.3 C & 38 & RD = IM2 $\ll$ IM1. Расширить IM2 знаком до 32 разрядов и сдвинуть результат влево на беззнаковое значение IM1, чтобы получить 32--разрядный скаляр (необязательна). \\
%move          & 1.3 C & 39 & RD = IM2 $\ll$ IM1. Sign-extend IM2 to 64 bits and shift left by the unsigned value IM1 to make 64 bit scalar (optional). \\
%add           & 1.3 C & 40 & RD += IM2 $\ll$ IM1. Add broadcast shifted signed constant to 32-bit vector elements (optional). \\
%add           & 1.3 C & 41 & RD += IM2 $\ll$ IM1. Add broadcast shifted signed constant to 64-bit vector elements (optional). \\
%and           & 1.3 C & 42 & RD \&= IM2 $\ll$ IM1. AND broadcast shifted signed constant with 32-bit vector elements (optional). \\
%and           & 1.3 C & 43 & RD \&= IM2 $\ll$ IM1. AND broadcast shifted signed constant with 64-bit vector elements (optional). \\
%or            & 1.3 C & 44 & RD \textbar{}= IM2 $\ll$ IM1. OR broadcast shifted signed constant with 32-bit vector elements (optional). \\
%or            & 1.3 C & 45 & RD \textbar{}= IM2 $\ll$ IM1. OR broadcast shifted signed constant with 64-bit vector elements (optional). \\
%xor           & 1.3 C & 46 & RD \^{}= IM2 $\ll$ IM1. XOR broadcast shifted signed constant with 32-bit vector elements (optional). \\
%xor           & 1.3 C & 47 & RD \^{}= IM2 $\ll$ IM1. XOR broadcast shifted signed constant with 64-bit vector elements (optional). \\
%add           & 1.3 C & 48 & RD += IM21 $\ll$ 16. Add broadcast signed 16-bit constant shifted left by 16 to 32-bit vector elements (optional). \\
%add           & 1.3 C & 49 & RD += IM21 $\ll$ 16. Add broadcast signed 16-bit constant shifted left by 16 to 64-bit vector elements (optional). \\
%mov           & 1.3 C & 56 & Move converted half precision floating point constant to single precision scalar (optional). \\
%mov           & 1.3 C & 57 & Move converted half precision floating point constant to double precision scalar (optional). \\
%add           & 1.3 C & 58 & Add broadcast half precision floating point constant to single precision vector (optional). \\
%add           & 1.3 C & 59 & Add broadcast half precision floating point constant to double precision vector (optional). \\
%mul           & 1.3 C & 60 & Multiply broadcast half precision floating point constant with single precision vector (optional). \\
%mul           & 1.3 C & 61 & Multiply broadcast half precision floating point constant with double precision vector (optional). \\
%permute       & 2.5 & 2, 8  & The vector elements of RT are permuted within each block of size RS bytes, using indices in RU. Each index is relative to the beginning of a block. An index out of range produces zero. The maximum block size is implementation dependent. \\
%concatenate   & 2.5 & 2, 9 & A vector RT of length RS and a vector RU of length RS are concatenated into a vector RD of length 2$\cdot$RS. \\
%truth\_tab3   & 2.5 & 3, 8 & Boolean function of three inputs, given by a truth table (optional). \\
%truth\_tab4   & 2.5 & 4, 8 & Boolean function of four inputs, given by a truth table (optional). \\
%mul\_add      & 2.5 & 3, 9 & RD = $\pm$ RS $\pm$ RT $\cdot$ RU (optional but recommended). \\
%add\_add      & 2.5 & 3, 10 & RD = $\pm$ RS $\pm$ RT $\pm$ RU (optional). \\
%add\_add\_add & 2.5 & 3, 11 & RD = $\pm$ RS $\pm$ RT $\pm$ RU $\pm$ IM2  Add three vector register operands and a 16-bit constant IM2 (optional). \\
%add\_add\_add & 2.5 & 4, 11 & RD = $\pm$ RD $\pm$ RS $\pm$ RT $\pm$ RU Add four vector register operands (optional). \\
%load\_hi      & 2.7 & 16 & Make vector of two elements. dest[0] = 0, dest[1] = IM2. \\
%insert\_hi    & 2.7 & 17 & Make vector of two elements. dest[0] = src1[0], dest[1] = IM2. \\
%make\_mask    & 2.7 & 18 & Make vector where bit 0 of each element comes from bits in IM2, the remaining bits come from RS. \\
%replace       & 2.7 & 19 & Replace elements in RS by constant IM2. \\
%replace\_even & 2.7 & 20 & Replace even-numbered elements in RS by constant IM2. \\
%replace\_odd  & 2.7 & 21 & Replace odd-numbered elements in RS by constant IM2. \\
%broadcast     & 2.7 & 22 & Broadcast 32-bit constant into all elements of RD with length RS (31 in RS field gives scalar output). \\
%permute       & 2.7 & 33 & The vector elements of RT are permuted within each block of size RS bytes. The 4$\cdot$n bits of IM2 are used as index with 4 bits for each element in blocks of size n. The same pattern is used in each block. The number of elements in each block, n = RS / OS $\leq$ 8. \\ \hline
\end{longtable}

%\begin{longtable} {|p{20mm}|p{10mm}|p{8mm}|p{75mm}|}
%\caption{List of single-format instructions with memory operands.} 
%\label{table:ListOfSingleFormatInstructionsMemory} \\
%\endfirsthead
%\endhead
%\hline
%\bfseries Instruction & \bfseries Format &\bfseries OP1, OP2 & \bfseries Description \\ \hline
%store         & 2.7 B & 48 & Store 32-bit constant IM2 to memory operand with base RT and 8-bit offset IM1 (optional). \\
%fence         & 2.4.x & 0, 8 & Memory fence. read, write or full indicated by OP3.  \\
%cmp\_swap     & 2.8.x & 1, 8 & Atomic compare and exchange.  \\
%read\_insert  & 2.4.0 2.4.3 & 2, 8 & Replace one element in vector RD, starting at offset 
%RS$\cdot$OS, with scalar memory operand (optional).  \\
%move\_store   & 2.4.x & 3, 8 & Conditional move and store.\newline
%                               Mask bits = 01 or 11: store RU.\newline 
%                               Mask bits = 10: store zero. \newline
%                               Mask bits = 11: store RD. \newline
%                               (optional). \\
%extract\_store& 2.4.0 & 3, 9 & Extract one element from vector RD, starting at offset RS$\cdot$OS, with size OS into memory operand with base RT and offset IM2 (optional). \\
%extract\_store& 2.4.3 & 3, 9 & Extract one element from vector RD, starting at offset RS$\cdot$OS, with size OS into memory operand with base RT, scaled index RU and unsigned limit RU $\leq$ IM2 (optional). \\
%compress\_store&2.4.1 & 3, 10 & Compress vector RD of length RS to a vector of half the length and half the element size. Double precision $\rightarrow$ single precision, 64-bit integer $\rightarrow$ 32-bit integer, etc. Store at memory with base RT, offset IM2, length RS/2 (optional). \\
%add\_store    & 2.4.x & 4, 8 & Add RD and RU, store the result to memory operand (optional). \\
%sub\_store    & 2.4.x & 4, 9 & Subtract RU from RD, store the result to memory operand (optional). \\
%mul\_store    & 2.4.x & 4, 10 & Multiply RD and RU, store the result to memory operand (optional). \\
%read\_memory\_\newline map  & 2.4.2 & 48, 8 & Read memory map. RD = map entry, RT = memory pointer, RS = vector length and negative index to both source and destination (privileged). \\
%write\_memory\_\newline map & 2.4.2 & 48, 9 & Write memory map. RD = map entry, RT = memory pointer, RS = vector length and negative index to both source and destination (privileged). \\ \hline
%\end{longtable}
\end{document}