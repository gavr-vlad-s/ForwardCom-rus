% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Микроархитектура и дизайн конвейера}
Набор команд ForwardCom предназначен для облегчения стабильного и эффективного дизайна конвейера суперскалярного микропроцессора. Команды могут иметь один операнд--приёмник, вплоть до трёх или четырёх операндов--источников, регистр маски, и регистр, указывающий длину вектора. Последний операнд--источник может быть регистром, находящимся в памяти операндом, или непосредственно заданной константой. Все другие операнды --- регистры, за исключением команд записи в память. Суммарное количество входных регистров команды, включая операнды--источники, маску, базовый указатель, индекс, и указание длины вектора, не может быть более пяти.

Никакая команда не может иметь более одного находящегося в памяти операнда. Никакая команда не может иметь и операнд--источник, находящийся в памяти, и непосредственно заданный операнд, хотя это может быть разрешено в последующих расширениях. Любые дополнительные поля непосредственно заданных операндов могут использоваться для разрядов опций. 

Высокопроизводительный конвейер может быть спроектирован как суперскалярный, со следующими стадиями.
\begin{itemize}
\item Выборка. Выборка блоков кода из кэша команд, по одной строке кэша за раз, либо так, как определено механизмом предсказания ветвлений. 

\item Декодирование длин команд. Определение длины каждой команды и определение малых команд. Распределение первых P команд в свою полосу конвейера, где P --- количество параллельных полос, реализованных в конвейере. Избыточные команды могут быть поставлены в очередь до следующего такта. 

\item Декодирование команды. Определение и классификация всех операндов, опкодов, и разрядов опций. Определение входных и выходных зависимостей.

\item Размещение и переименование регистров.

\item Очередь команд. 

\item Помещение команд в станцию восстановления. Планирование для вычислителя адресов. 

\item Вычисление адреса и длины находящегося в памяти операнда. Проверка прав доступа.

\item Чтение операнда из памяти. Планирование для исполнительных модулей.  

\item Исполнительные модули.  

\item Восстановление или ветвление. 
\end{itemize}

Ненужно разбивать команды на микрооперации, если чтение находящихся в памяти операндов выполняется на отдельной стадии конвейера, и командам разрешается оставаться в станции восстановления до тех пор, пока не будет прочитан находящийся в памяти операнд.

Каждой стадии конвейера в идеале следует требовать лишь одного такта. Командам, ожидающим операндов, следует оставаться в станции восстановления. Большинство команд в исполнительном модуле будет использовать лишь один такт. Умножению и вещественному сложению нужен конвейеризованный исполнительный модуль с несколькими стадиями. Деление и квадратный корень могут использовать отдельный конечный автомат.

Команды перехода, ветвления, вызова, и возврата также подпадают под этот дизайн конвейера.

Станция восстановления должна рассматривать все входные и выходные зависимости каждой команды. Каждая команда может иметь вплоть до пяти входных зависимостей и одну выходную. 

Может быть много исполнительных модулей, так что возможен запуск нескольких команд в одном и том же такте, если их операнды независимы.

Эффективная неупорядоченная обработка требует переименования регистров общего назначения и векторных регистров, но ненужна для специальных регистров. 

Сложных команд и микрокода в большинстве случаев следует избегать. У нас нет команд сохранения и восстановления всех регистров при переключении задач. Вместо этого необходимые команды сохранения и восстановления регистров реализованы как малые команды, чтобы уменьшить размер последовательности команд, сохраняющей все регистры.

Следующие команды умеренно сложны: call, return, div, rem, sqrt, cmp\_swap, save\_cp, restore\_cp. Эти команды можно реализовать специальными конечными автоматами. То же применимо к ловушкам, прерываниям, и системным вызовам.

У некоторых современных ЦП есть \glqq стековый модуль\grqq, чтобы предсказывать значение указателя стека для команд push, pop, или call, когда предшествующие стековые операции запаздывают из--за операндов, которые ещё недоступны. Такая система ненужна, если у нас имеется двухстековый дизайн (см. с.~\pageref{dualStack}). Даже при одностековом дизайне, в стековом модуле нужды мало, так как операции  push и pop будут редки в критичной части кода, если придерживаться соглашений вызова, предлагаемых в настоящем документе (с.~\pageref{functionCallingConventions}). 

Предсказание ветвления важно для производительности. Мы можем реализовать четыре различных алгоритма предсказания ветвлений: один для обыкновенных ветвлений, один --- для циклов, один --- для косвенных переходов, и один --- для возвратов из функций. У длинной формы команд ветвления имеется разряд опции для указания поведения цикла. В короткой форме команд ветвления места для такого разряда нет. Первоначальная догадка может состоять в предположении циклического поведения, если ветвление выполняет переход назад, и обычного ветвления, если ветвление выполняет переход вперёд. Если необходимо, это предположение может быть позднее скорректировано механикой  предсказания ветвлений. 

Код, следующий за ветвлением, спекулятивно выполняется, пока не определяется, было ли правильным предсказание. Мы можем реализовать возможности для одновременного спекулятивного выполнения обеих ветвей.

Дизайн  ForwardCom позволяет большие микропроцессоры с очень длинными векторными регистрами, что требует специальных обсуждений дизайна. 
% The chip layout of vector processors is typically divided into ``data lanes'' so that the vertical transfer of data from a vector element to the corresponding 
%vector element in another vector (i. e. same lane) is faster than the horizontal transfer of data from one vector element to another element at another position of the same vector (i. e. different lane). This means that instructions that transfer data horizontally across a vector, such as broadcast and permute instructions, may have longer latencies than other vector instructions. The scheduler needs to know the instruction latency, and this can be a problem if the latency depends on the distance of data transfer on very long vectors. This problem is addressed by indicating the vector length or the distance of data transfer for such instructions in a separate operand, which always uses the RS register field. This information may be redundant because the vector length is stored in the vector register operands, but the scheduler needs this information as early as possible. The other register operands are typically not ready until the clock cycle where they go to the execution unit, while the vector length is typically known earlier. The microprocessor can read the RS register at the address calculation stage in the pipeline, where it also reads any pointer, index register and vector length for memory operands. This allows the scheduler to predict the latency a few clock cycles in advance. The instruction set provides the extra information about vector length or data transfer length in RS for all instructions that involve horizontal data transfer, including memory broadcast, permute, insert, extract and shift instructions, but not broadcasting of immediate constants. 
%\vspace{2mm}
%
%The data path to the data cache and memory should be quite wide, possibly matching the maximum vector length, because cache access and memory access are typical bottlenecks.
\end{document}