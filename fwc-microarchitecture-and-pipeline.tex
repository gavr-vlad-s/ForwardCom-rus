% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Микроархитектура и дизайн конвейера}
Набор команд ForwardCom предназначен для облегчения стабильного и эффективного дизайна конвейера суперскалярного микропроцессора. Команды могут иметь один операнд--приёмник, вплоть до трёх или четырёх операндов--источников, регистр маски, и регистр, указывающий длину вектора. Последний операнд--источник может быть регистром, находящимся в памяти операндом, или непосредственно заданной константой. Все другие операнды --- регистры, за исключением команд записи в память. Суммарное количество входных регистров команды, включая операнды--источники, маску, базовый указатель, индекс, и указание длины вектора, не может быть более пяти.

Никакая команда не может иметь более одного находящегося в памяти операнда. Никакая команда не может иметь и операнд--источник, находящийся в памяти, и непосредственно заданный операнд, хотя это может быть разрешено в последующих расширениях. Любые дополнительные поля непосредственно заданных операндов могут использоваться для разрядов опций. 

Высокопроизводительный конвейер может быть спроектирован как суперскалярный, со следующими стадиями.
\begin{itemize}
\item Выборка. Выборка блоков кода из кэша команд, по одной строке кэша за раз, либо так, как определено механизмом предсказания ветвлений. 

\item Декодирование длин команд. Определение длины каждой команды и определение малых команд. Распределение первых P команд в свою полосу конвейера, где P --- количество параллельных полос, реализованных в конвейере. Избыточные команды могут быть поставлены в очередь до следующего такта. 

\item Декодирование команды. Определение и классификация всех операндов, опкодов, и разрядов опций. Определение входных и выходных зависимостей.

\item Размещение и переименование регистров.

\item Очередь команд. 

\item Помещение команд в станцию восстановления. Планирование для вычислителя адресов. 

\item Вычисление адреса и длины находящегося в памяти операнда. Проверка прав доступа.

\item Чтение операнда из памяти. Планирование для исполнительных модулей.  

\item Исполнительные модули.  

\item Восстановление или ветвление. 
\end{itemize}

Ненужно разбивать команды на микрооперации, если чтение находящихся в памяти операндов выполняется на отдельной стадии конвейера, и командам разрешается оставаться в станции восстановления до тех пор, пока не будет прочитан находящийся в памяти операнд.

Каждой стадии конвейера в идеале следует требовать лишь одного такта. Командам, ожидающим операндов, следует оставаться в станции восстановления. Большинство команд в исполнительном модуле будет использовать лишь один такт. Умножению и вещественному сложению нужен конвейеризованный исполнительный модуль с несколькими стадиями. Деление и квадратный корень могут использовать отдельный конечный автомат.

Команды перехода, ветвления, вызова, и возврата также подпадают под этот дизайн конвейера.

Станция восстановления должна рассматривать все входные и выходные зависимости каждой команды. Каждая команда может иметь вплоть до пяти входных зависимостей и одну выходную. 

Может быть много исполнительных модулей, так что возможен запуск нескольких команд в одном и том же такте, если их операнды независимы.

Эффективная неупорядоченная обработка требует переименования регистров общего назначения и векторных регистров, но ненужна для специальных регистров. 

Сложных команд и микрокода в большинстве случаев следует избегать. У нас нет команд сохранения и восстановления всех регистров при переключении задач. Вместо этого необходимые команды сохранения и восстановления регистров реализованы как малые команды, чтобы уменьшить размер последовательности команд, сохраняющей все регистры.

Следующие команды умеренно сложны: call, return, div, rem, sqrt, cmp\_swap, save\_cp, restore\_cp. Эти команды можно реализовать специальными конечными автоматами. То же применимо к ловушкам, прерываниям, и системным вызовам.

У некоторых современных ЦП есть \glqq стековый модуль\grqq, чтобы предсказывать значение указателя стека для команд push, pop, или call, когда предшествующие стековые операции запаздывают из--за операндов, которые ещё недоступны. Такая система ненужна, если у нас имеется двухстековый дизайн (см. с.~\pageref{dualStack}). Даже при одностековом дизайне, в стековом модуле нужды мало, так как операции  push и pop будут редки в критичной части кода, если придерживаться соглашений вызова, предлагаемых в настоящем документе (с.~\pageref{functionCallingConventions}). 

Предсказание ветвления важно для производительности. Мы можем реализовать четыре различных алгоритма предсказания ветвлений: один для обыкновенных ветвлений, один --- для циклов, один --- для косвенных переходов, и один --- для возвратов из функций. У длинной формы команд ветвления имеется разряд опции для указания поведения цикла. В короткой форме команд ветвления места для такого разряда нет. Первоначальная догадка может состоять в предположении циклического поведения, если ветвление выполняет переход назад, и обычного ветвления, если ветвление выполняет переход вперёд. Если необходимо, это предположение может быть позднее скорректировано механикой  предсказания ветвлений. 

Код, следующий за ветвлением, спекулятивно выполняется, пока не определяется, было ли правильным предсказание. Мы можем реализовать возможности для одновременного спекулятивного выполнения обеих ветвей.

Дизайн  ForwardCom позволяет большие микропроцессоры с очень длинными векторными регистрами, что требует специальных обсуждений дизайна. Макеты кристаллов векторных процессоров обычно делятся на \glqq полосы данных\grqq, так что вертикальная передача данных от элемента вектора в соответствующий (т.е. в той же полосе) элемент другого вектора быстрее горизонтальной передачи данных из одного элемента вектора в другую (т.е в другой полосе) позицию того же вектора. Это означает, что команды, передающие данные горизонтально вдоль вектора, такие, как команды broadcast и permute, могут иметь более длинные задержки, нежели другие векторные команды. Планировщику нужно знать задержку команды, и это может быть проблемой, если задержка зависит от расстояния передачи данных по очень большим векторам. Эта проблема для таких команд решается указанием длины вектора или расстояния передачи данных в отдельном операнде, который всегда использует регистровое поле RS. Данные сведения могут быть избыточными, ибо длина вектора хранится в векторном регистровом операнде, но планировщику они нужны как можно раньше. Другие регистровые операнды обычно не готовы, пока не истечёт такт, на котором они пройдут через исполнительный модуль, тогда как длина вектора обычно известна раньше. Микропроцессор может прочесть регистр RS на стадии вычисления адреса, на которой он также читает любые указатели, индексные регистры, и длину вектора для находящихся в памяти операндов. Это позволяет планировщику прогнозировать задержку за несколько тактов. Набор команд для всех команд, включающих в себя горизонтальную передачу данных (сюда входят команды broadcast с операндом, находящимся в памяти, permute, insert, extract, и команды сдвига, и не входят команды рассылки непосредственно заданных констант), предоставляет дополнительные сведения о длине вектора или расстоянии передачи данных в поле RS. 

Путь данных к кэшу данных и памяти должен быть как можно более широким, возможно, с отслеживанием максимальной длины вектора, поскольку обращения к кэшу и памяти --- типичные узкие места.
\end{document}