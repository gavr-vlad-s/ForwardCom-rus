% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}

\section{Описание команд}
В данном разделе описываются команды, для которых нужны специальные объяснения.

\subsection{Многоформатные команды}
\subsubsection{nop}
Рекомендуется кодировать команды NOP в виде 32--разрядного слова, все разряды которого равны нулю. Процессору разрешается пропускать такого рода команды NOP на ранней стадии конвейера, и настолько быстро, насколько он может. Пара малых команд, в которой вторая команд --- NOP, может рассматриваться как одна команда.

Эти команды NOP могут использоваться только как заполнители, но не для задержек.

\subsubsection{move}
Копирование значения из находящегося в памяти операнда, регистра, или непосредственно заданной константы в регистр. Если приёмник --- векторный регистр, а источник --- непосредственно заданная константа, то результат будет скаляром. Значение размножено не будет, поскольку нет никакого иного входного операнда, который бы указывал длину вектора. Если желателен вектор, то используйте команду broadcast.

Команда move с непосредственно заданным операндом  --- предпочтительный метод обнуления регистра.

Команда move  имеет несколько дополнительных малых и одноформатных вариантов. Ассемблер, как правило, выберет самый короткий вариант, в который помещаются указанные операнды.

\subsubsection{store}
Операнды--источники и операнды--приёмники меняются ролями, так что значение из RD записывается в находящийся в памяти операнд. Допускаются только форматы, которые указывают находящийся в памяти операнд (скалярный, либо векторный без размножения).

Размер находящегося в памяти операнда определяется полем размера операнда (OS), когда указан находящийся в памяти скалярный операнд, или длиной векторного регистра в RS, когда указан находящийся в памяти векторный операнд.

Аппаратура должна быть в состоянии обрабатывать размеры находящихся в памяти операндов, не являющиеся степенями двойки, не используя при этом дополнительной памяти (чтение и перезапись за пределами находящегося в памяти операнда --- не допускаются, разве что обращение из других потоков блокировано во время выполнения операции, и подавляются исключения отсутствия доступа). Разрешается записывать операнд по кусочкам.

Замаскированная операция с разрядами маски №№ 0 и 1, равными нулю одновременно, запишет в память ноль.

Замаскированная операции с разрядом №0, равным 0, и разрядом №1, равным единице, для векторных регистров может поддерживаться, а может и не поддерживаться. Если поддерживается, то эта комбинация оставит ячейку памяти без изменения, и не может быть реализована как чтение, совмещённое с записью, поскольку это не было бы потокобезопасно.

\subsubsection{prefetch}
Предвыборка находящегося в памяти операнда в кэш. Разные варианты могут указываться разрядами №№0--3 поля OP3 форматов 2.4 и 2.8.

\subsubsection{sign\_extend}
Входным операндом может быть 8--разрядное, 16--разрядное, или 32--разрядное целое число. Это целое число расширяется знаком, чтобы получить 64--разрядный результат в регистре общего назначения или скаляр в векторном регистре. Если входной операнд --- вектор, то в каждом 64--разрядном блоке используется только первый элемент. Вещественные типы использоваться не могут.

\subsubsection{min and max}
min(src1,src2) = src1 \textless{} src2 ? src1 : src2

max(src1,src2) = src1 \textless{} src2 ? src1 : src2

Операнды рассматриваются как знаковые. Есть также версия для беззнаковых целых:

min\_u(src1,src2) = src1 \textless{} src2 ? src1 : src2

max\_u(src1,src2) = src1 \textless{} src2 ? src1 : src2

Когда беззнаковая версия применяется к вещественным операндам, она берёт абсолютные величины операндов, и имя команды изменяется:

min\_abs(src1, src2) = min(abs(src1), abs(src2))

max\_abs(src1, src2) = max(abs(src1), abs(src2))

Обработка вещественных операндов, являющихся нечислами (NAN), определяется разрядом №22 регистра маски или вещественного управляющего регистра. Если разряд №22 равен нулю, то, в соответствии с  IEEE Standard 754-2008, результатом является не являющийся нечислом операнд. Если разряд №22 равен единице, то входной операнд, являющийся NAN, распространяется дальше.

Являющийся NAN операнд, который не является распространяемым, породит ловушку, если установлен флаговый разряд №29.

\subsubsection{Поразрядные логические команды}
Это следующие команды: and, and\_not, or, xor. Вещественные операнды обрабатываются точно так же, как и целочисленные.

\subsubsection{Команды манипуляции разрядами}
Для манипуляции разрядами предоставляются следующие команды: 

extract\_b: выделить разряд с номером src2 из src1

set\_b: заменить в src1 разряд с номером src2 на 1

clear\_b: заменить в src1 разряд с номером src2 на 0

toggle\_b: инвертировать в src1 разряд с номером src2

Вещественный операнд в src1 рассматривается как целое число такого же размера. Индекс разряда в src2, независимо от типа операнда, интерпретируется как 8--разрядное беззнаковое целое число.

Эти команды могут быть реализованы с 8--разрядной непосредственно заданной константой для src2, вместо большей константы, которая потребовалась бы, если бы мы использовали команды AND, OR, XOR для манипулирования одиночными разрядами. Эти команды могут также использоваться с вещественными числами, в основном для манипулирования знаковым разрядом.

\subsubsection{mul\_add}
Совмещённые умножение и сложение.

dest = $\pm$ src1 $\pm$ (src2 $\cdot$ src3)

Команда совмещённого умножения и сложения часто может значительно улучшить производительность вещественного кода.

Поддерживаются только форматы, допускающие три операнда.

Знаки операндов могут быть изменены, что указывается в разрядах №№0--3 поля OP3 в форматах, использующих шаблон E2, включая дополнительный формат 2.5, при этом

разряд 0: изменить знак у элементов вектора src1 с чётными номерами

разряд 1: изменить знак у элементов вектора src1 с нечётными номерами

разряд 2: изменить знак у элементов вектора src2$\cdot$src3  с чётными номерами

разряд 3: изменить знак у элементов вектора src2$\cdot$src3  с нечётными номерами

Команда делает возможным выполнение умножения--и--сложения, умножения--и--вычитания, умножения--и обратного--вычитания, и т.п. Можно также выполнять умножение с чередующимися сложением и вычитанием, что полезно при вычислениях с комплексными числами. В других форматах, в которых поле OP3 отсутствует, смены знака нет. Поддерживается дополнительная одноформатная версия mul\_add, с четырьмя регистровыми операндами и полем OP3.

Поле OP3 не используется как счётчик сдвига в форматах 2.5 и 2.9.

Поддержка целочисленных операндов --- необязательна. Поддержка вещественных операндов --- необязательна, но желательна.

\subsubsection{add\_add}  \label{addAdd}
Два сложения в одной команде.

dest = $\pm$ src1 $\pm$ src2 $\pm$ src3

Поддерживаются только форматы, допускающие три операнда.

Знаки операндов могут быть изменены, что указывается в разрядах №№0--2 поля OP3 в форматах, использующих шаблон E2, включая дополнительный формат 2.5, при этом

bit 0: изменить знак src1

bit 1: изменить знак src2

bit 2: изменить знак src3

В других форматах, в которых поле OP3 отсутствует, смены знака нет. Поддерживается дополнительная одноформатная версия add\_add, с четырьмя регистровыми операндами и полем OP3. 

Поле OP3 не используется как счётчик сдвига в форматах 2.5 и 2.9.

Желательна точность вещественных операндов, меньшая единицы самого младшего разряда численно самого большого операнда, но промежуточный результат не вычисляется с неограниченной точностью. Аппаратная реализация может подстроить экспоненты для всех операндов за первый такт, и использовать сеть сумматора цепи умножения.

Данную команду следует поддерживать, только если её можно реализовать так, чтобы она была быстрее двух последовательных команд сложения. Она может поддерживаться для целочисленных операндов, вещественных операндов, или и для тех, и для других. См. также команду add\_add\_add (с.~\pageref{addAddAdd}).

\subsubsection{Команды сравнения}
Команда сравнения сравнивает два операнда--источника и сохраняет результат в разряде №0 приёмника. Когда используются форматы 0.0-0.3 или 2.0-2.3, условие определяется добавочным кодом, сохранённым в третьем операнде--источнике. Форматы, использующие шаблон E2 (2.4, 2.5, 2.8, 2.9) кодируются иначе: код условия содержится в поле OP3. Шестнадцатиразрядное поле IM2 форматов  2.5 и 2.9 используется как второй операнд--источник, который не сдвигается на  OP3.

Оставшиеся разряды результата копируются из регистра маски, или из численного управляющего слова, если маска не используется. Это подходит, когда результат используется как маска.

Коды условий определены в следующей таблице:

\begin{longtable} {|l|p{100mm}|}
\caption{Коды условий для команд сравнения} 
\label{table:conditionCodesForCompareInstruction} \\
\endfirsthead
\endhead
\hline
\bfseries Разряд & \bfseries Смысл      \\ \hline
0                & Инвертирует условие. \\ \hline
1-2              & Определяет условие: \newline
				      0 = меньше,\newline
				      1 = равно,\newline
				      2 = больше,\newline
				      3 = неупорядочено.         \\ \hline
3   			& Для целочисленных операндов: \newline
			      0 = знаковые операнды,\newline
			      1 = беззнаковые операнды.\newline
			      Для вещественных операндов:\newline
			      данный разряд указывает результат, если один операнд, либо оба, являются нечислами (NAN). \\ \hline
\end{longtable}

Команды сравнения могут быть замаскированы. Разряд №0 результата равен разряду №1 регистра маски, если разряд №0 регистра маски равен нулю.

\subsection{Команды малого формата}
\subsubsection{clear}
Данная команда устанавливает длину векторного регистра равной нулю. Всё содержимое теряется. Регистр может затем рассматриваться как неиспользуемый.

\subsubsection{Операции push и pop}
Команд push и pop нет. Регистр общего назначения R можно втолкнуть в стек с помощью следующей пары малых команд:
\begin{verbatim}
    add sp,-8
    store [sp],R
\end{verbatim}

Регистр общего назначения R можно вытолкнуть из стека с помощью следующей пары малых команд:
\begin{verbatim}
    move R,[sp] 
    sub sp,-8
\end{verbatim}
Обратите внимание, что константа -8 может содержаться в 4--разрядном знаковом поле RS, а константа 8 --- нет. Именно по этой причине мы прибавляем и вычитаем -8, а не выполняем обратные операции с +8.

Для этих последовательностей ассемблер может поддерживать макросы с именами push и pop.

\subsubsection{Сохранение и восстановление векторных регистров} \label{saveRestoreVectorRegisters}
При сохранении векторного регистра переменной длины мы не хотим сохранять максимальную длину, когда используется только часть регистра. Как следствие, вы имеем команды save\_cp и restore\_cp, предназначенные для сохранения и восстановления векторных регистров без использования большего объёма памяти, нежели необходимо.

Обратите внимание, что формат сохранённого образа зависит от реализации. Как правило, команда save\_cp сохранит длину вектора, за которой  следует столько байтов, сколько указано длиной, а команда restore\_cp прочтёт длину, а затем прочтёт столько байтов, сколько указано длиной.

Микропроцессору разрешается сжимать данный любым способом, который можно обработать достаточно быстро. Например, булев вектор, использующий только один разряд в каждом элементе, может, очевидно, быть сжат до гораздо меньшего размера. Образ неиспользуемого векторного регистра будет, как правило, содержать несколько нулевых байтов для длины.

Программному обеспечению никогда не следует использовать сохранённый образ ни для чего иного, нежели восстановление векторного регистра на той же модели микропроцессора, что сохранила его, поскольку формат образа несовместим у разных моделей.

Размер сохранённого образа можно прибавить к указателю командой add\_cps или вычесть из указателя командой sub\_cps. Поле RS задаёт указатель, которым может быть r0--14 или r31 (указатель стека).

Векторный регистр V можно сохранить в стеке (втолкнуть в стек) с помощью следующей пары малых команд: 
\begin{verbatim}
   sub_cps sp,V
   save_cp [sp],V
\end{verbatim}

Векторный регистр V можно восстановить из стека (вытолкнуть) с помощью следующей пары малых команд:
\begin{verbatim}
   restore_cp V,[sp]
   add_cps sp,V
\end{verbatim}

Те же команды можно использовать для сохранения регистров при переключении задач. При сохранении таким способом, неиспользуемые векторные регистры будут использовать очень мало места.

Размер сжатого образа, указываемого командами add\_cps и sub\_cps, при использовании указателя стека должен быть кратным 8, чтобы сохранить должное выравнивание стека. 

При переключении задач, когда, как правило, используется другой указатель команд, разрешается использовать меньший размер, не кратный 8. В этом случае для управления форматом сохранённого образа должен быть предоставлен управляющий регистр.

Команде restore\_cp разрешается читать больше байтов, чем необходимо, вплоть до значения, равного максимальной длине вектора плюс 8 байт, и отбрасывать впоследствии, когда станет известна действительная длина, любые избыточные байты.

\subsection{Одноформатные команды, использующие регистры общего назначения и специальные регистры}
\subsubsection{read\_spe, write\_spe}
Чтение или запись специального регистра. Ниже указаны определённые на данный момент специальные регистры. Разрядность каждого равна 64. Эти регистры инициализируются их принятыми по умолчанию значениями в момент запуска программы.

\begin{longtable} {|l|l|}
\caption{Список специальных регистров} 
\label{table:specialRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Номер специального регистра & \bfseries Смысл  \\ \hline
0                                     & Численный управляющий регистр (NUMCONTR).  \\
1 									  & Идентификатор (ID) марки микропроцессора  \\
2                                     & Номер версии микропроцессора.   \\
28                                    & Указатель блока окружения потока (THREADP).   \\
29                                    & Указатель секции данных (DATAP).  \\
\hline
\end{longtable}

\subsubsection{read\_cpb, write\_cpb}
Чтение или запись регистра возможностей процессора. Эти регистры используются для указания возможностей процессора, таких, как поддержка необязательных команд и ограничения на длину вектора. Разрядность такого регистра равна 64. В момент запуска программы эти регистры инициализируются принятыми для них по умолчанию значениями.

Находящаяся в IM1 непосредственно заданная константа определяет детали операции:

\begin{longtable} {|p{20mm}|p{128mm}|}
\caption{Смысл непосредственно заданной константы в командах read\_cpb и write\_cpb} 
\label{table:readWriteCpbModes} \\
\endfirsthead
\endhead
\hline
\bfseries Номер разряда & \bfseries Смысл  \\ \hline
0                       &  0: чтение/запись возможностей для типа операнда, указанного в разрядах №№5-7.\newline
                           1: чтение типичных возможностей для всех типов операндов / запись возможностей для всех соответствующих типов операндов.  \\ \hline
1                       &  0: чтение текущего значения регистра, которое, возможно, изменено.\newline
                           1: чтение реальных возможностей аппаратуры (записывать нельзя). \\ \hline
5-7                     & Тип операнда для возможностей. \\ \hline
\end{longtable}

\begin{longtable} {|p{20mm}|p{110mm}|}
\caption{Список регистров возможностей} 
\label{table:capabilitiesRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Номер регистра возможностей & \bfseries Смысл  \\ \hline
0  &  Максимальная длина вектора для команд общего назначения. \\ \hline
1  &  Максимальная длина вектора для команд перестановки. \\ \hline
2  &  Максимальная длина блока для команд перестановки. \\ \hline
3  &  Максимальная длина вектора для compress\_sparse и expand\_sparse. \\ \hline
8  &  Поддержка необязательных команд, работающих с регистрами общего назначения. Каждый разряд отвечает за свою команду. \\ \hline
9  &  Поддержка необязательных команд, работающих со скалярами в векторных регистрах. Каждый разряд отвечает за свою команду.  \\ \hline
10 &  Поддержка необязательных команд, работающих с векторами. Каждый разряд отвечает за свою команду.  \\ \hline
\end{longtable}

Изменение значений максимальной длины вектора оказывает следующее влияние. Если максимальная длина уменьшается до величины, меньшей физически возможной, то любая попытка сделать более длинный вектор даст вектор с уменьшенной длиной. Поведение векторных регистров, у которых до уменьшения максимальной длины уже была большая длина, зависит от реализации. Если максимальная длина устанавливается равной значению, которое больше физически возможного, то любая попытка сделать вектор размера, большего физически возможного, вызовет ловушку, для облегчения эмуляции. Регистры возможностей с номерами 0--3 для целей эмуляции могут быть увеличены. Значение регистров возможностей с номерами 0--3 должно быть степенью двойки.

Регистры возможностей с номерами 8--9 могут модифицироваться, для тестовых целей или для того, чтобы сообщить программному обеспечению: \glqq не используй конкретные команды\grqq. То же значение будет возвращаться при чтении регистра. Попытка выполнить неподдерживаемую команду вызовет ловушку, независимо от значения регистра возможностей.

\subsubsection{read\_sys, write\_sys}
Эти команды предназначены для обращения к различным регистрам, доступным только для чтения.

\subsubsection{read\_perf}
Прочесть внутренний счётчик тактов, количество выполненных команд, или иные связанные с производительностью счётчики.

\subsubsection{read\_perfs}
То же, что и read\_perf. Данная команда сериализуется. Это означает, что она не может выполняться неупорядоченно.

\subsubsection{popcount}
Команда popcount считает количество единичных разрядов в целом числе. Она может также использоваться для генерирования чётности.

\subsubsection{bitscan\_f}
Сканировать разряды вперёд.

Найти индекс самого младшего единичного разряда, т.е. наибольшее  X, для которого

(((1 $\ll$ X) - 1) \& src1)) == 0.

\subsubsection{bitscan\_r}
Сканировать разряды назад.

Найти индекс самого старшего единичного разряда, т.е. наибольшее  X, для которого (1 $\ll$ X) $\leq$ src1.

\subsubsection{round\_d2}
Округлить к ближайшей степени двойки, т.е. 1 $\ll$ bit\_scan\_reverse(src1).

\subsubsection{round\_u2}
Округлить к ближайшей большей степени двойки, т.е.

(S \& (S-1)) == 0 ? S : 1 $\ll$  (bit\_scan\_reverse(S) + 1),

где S = src1.

\subsubsection{shift\_add}
Сдвинуть и сложить, dest = src1 + (src2 $\ll$  src3); src1 использует тот же регистр, что dest; src3 --- 8--разрядная знаковая непосредственно заданная константа.

Если src3 --- отрицательно, то будет выполняться сдвиг вправо.

\subsubsection{address}
Вычислить адрес относительно указателя, сложив 32--разрядную расширенную знаком константу с регистром общего назначения или специальным регистром. Регистром--указателем может быть r0-r27, THREADP (28), DATAP (29), IP (30) или SP(31).

\subsubsection{cmp\_swap}
Команда атомарного сравнения и обмена, используемая для синхронизации и безблокировочного разделения данных между потоками; src1 и src2 --- регистровые операнды; src3 --- находящийся в памяти операнд, который должен быть выровнен по естественному адресу. Все операнды рассматриваются как целочисленные, независимо от указанного типа операнда. Операция выполняется так:
\begin{verbatim}
   temp = src3;
   if (temp == src1) src3 = src2;
   return temp;
\end{verbatim}

Если необходимо, могут быть реализованы и другие атомарные команды (в формате 2.8 с OP1 = 1 и увеличивающимися значениями в OP2).

\subsection{Одноформатные команды с РОН в качестве входного операнда и векторным регистром в качестве выходного, или наоборот}
\subsubsection{gp2vec}
Значение регистра общего назначения копируется в находящийся в векторном регистре скаляр. Длина будет равна размеру операнда. Никаких преобразований типа не выполняется.

\subsubsection{vec2gp}
Первый элемент векторного регистра копируется в регистр общего назначения. Если указан целочисленный тип, имеющий разрядность, меньшую 64, то значение знаком расширяется до 64 разрядов. Если указан тип \glqq вещественное число одинарной точности\grqq, то значение расширяется нулём до 64 разрядов. Никаких иных преобразований типов не выполняется.

\subsubsection{set\_len}
Устанавливает длину векторного регистра равной количеству байт, указанному в регистре общего назначения. Если указанная длина больше длины, максимально допустимой для указанного типа операнда, то будет использоваться максимальная длина.

Если выходной вектор длиннее входного, то дополнительные элементы будут нулями. Если выходной вектор --- короче входного, то лишние элементы будут отброшены.

\subsubsection{get\_len}
Получает длину векторного регистра (в байтах). Результат сохраняется в регистре общего назначения.

\subsubsection{set\_num}
То же, что и set\_len, но длина умножается на размер операнда.

\subsubsection{get\_num}
То же, что и  get\_len, но длина делится на размер операнда.

\subsubsection{mask\_length}
Сделать булев вектор, для того, чтобы замаскировать первые n элементов вектора, где n = RS / (размер операнда). Выходной вектор RD будет иметь ту же длину, что и входной вектор RD. RS указывает длину части, которая разрешается маской. IM1 содержит следующие разряды опций:\\
разряд №0 = 0: разряд №0 будет равен 1 в первых n элементах результата, и 0 --- в остальных; \\
разряд №0 = 1: разряд №0 будет равен 0 в первых n элементах результата, и 1--- в остальных; \\
разряд №1 = 1: разряд №1 всех элементов результата равен 1; \\
разряд №2 = 1: копировать разряд №1 каждого элемента из входного вектора RD; \\
разряд №3 = 1: копировать разряд №1 каждого элемента из численного управляющего регистра; \\
разряд №4 = 1: копировать оставшиеся разряды из входного вектора RD; \\
разряд №5 = 1: копировать оставшиеся разряды из численного управляющего регистра. \\
Разряды результата, не установленные никакой из этих опций, будут нулями.

\subsubsection{make\_sequence}
Сделать вектор, длина которого равна RS байтов. Количество элементов равно RS/(размер операнда). Первый элемент равен IM1, следующий элемент --- IM1+1, и т.д. Поддержка вещественных чисел --- необязательна.


\subsection{Другие одноформатные команды, которые могут изменять длину вектора}
\subsubsection{bits2bool}
Расширить смежные разряды векторного регистра до булева вектора, с одним разрядом в каждом элементе

\subsubsection{bool2bits}
Преобразовать булев вектор из n элементов в n непрерывных разрядов векторного регистра. Длина результирующего вектора будет равна степени двойки, достаточной для хранения n разрядов.

\subsubsection{shift\_expand}
Длина вектора увеличивается на указанное количество байтов, посредством сдвига всех байтов вправо и добавления нулевых младших байтов. Если получившаяся длина больше  максимальной длины вектора для указанного типа операнда, то старшие байты теряются.

\subsubsection{shift\_reduce}
Длина вектора уменьшается на указанное количество байтов, посредством сдвига всех байтов вправо. Если получившаяся длина меньше нуля, то результатом будет вектор нулевой длины. Указываемый тип операнда --- игнорируется.

\subsubsection{compress}
Элементы вектора преобразуются к элементам половинного размера. Длина результирующего вектора будет равна половине длины входного вектора. Поле OT указывает тип операнда входного вектора. Вещественные числа двойной точности преобразуются в числа одинарной точности. Целочисленные элементы преобразуются к половинному размеру отбрасыванием старших разрядов. Поддержка следующих преобразований необязательна: одинарная точность в половинную, четырёхкратная точность в двойную, 8--разрядное целое в 4--разрядное.

Если длина входного вектора отличается от длины, указанной в RS, то перед сжатием длина преобразуется к длине в RS.

\subsubsection{compress\_ss}
То же, что и compress. Целые числа трактуются как знаковые, и сжимаются с насыщением. Вещественные операнды использоваться не могут. Данная команда необязательна.

\subsubsection{compress\_us}
То же, что и compress. Целые числа трактуются как беззнаковые, и сжимаются с насыщением. Вещественные операнды использоваться не могут. Данная команда необязательна.

\subsubsection{expand}
Это операция, обратная к compress. Результирующий вектор имеет указанную длину, а входной вектор --- половинную длину. Поле OT указывает тип операнда выходного вектора. Вещественные числа одинарной точности преобразуются в числа двойной точности. Целые числа преобразуются в числа двойного размера расширением знаком. Поддержка следующих преобразований необязательна: половинная точность в одинарную, двойная точность в четырёхкратную, 4--разрядное целое в 8--разрядное.

Если длина входного вектора отличается от RS/2, то перед расширением она преобразуется. Если получившаяся длина превышает максимальную длину вектора для указанного типа операнда, то лишние элементы теряются.

\subsubsection{expand\_us}
То же, что expand. Целые числа расширяются знаком. Вещественные операнды использоваться не могут.

\subsection{Одноформатные команды, которые могут перемещать данные горизонтально из одного вектора в другой}
Для очень длинных векторов задержка этих команд может зависеть от расстояния перемещения (указанного в RS).

\subsubsection{extract}
Выделить один элемент вектора в скаляр, находящийся в векторном регистре. Находящийся вне диапазона индекс порождает нулевой результат. Может использоваться размер операнда, равный 16 байтам, даже если этот размер никак иначе не поддерживается.

\subsubsection{insert}
Заменить один элемент вектора, вставив скаляр в позицию, указанную индексом. Находящийся вне диапазона индекс оставит вектор без изменения. Может использоваться размер операнда, равный 16 байтам, даже если этот размер никак иначе не поддерживается.

\subsubsection{shift\_up}
Сдвинуть элементы вектора влево на количество элементов, указанное в RS. Младшие RS элементов приёмника становятся нулями, а старшие RS элементов источника --- теряются.

Данная команда отличается от shift\_expand тем, что величина сдвига указывается как количество элементов, а не количество байтов, и тем, что длина вектора не изменяется.

\subsubsection{shift\_dn}
Сдвинуть элементы вектора вправо на количество элементов, указанное в RS. Старшие RS элементов приёмника становятся нулями, а младшие RS элементов источника --- теряются.

Данная команда отличается от shift\_reduce  тем, что величина сдвига указывается как количество элементов, а не количество байтов, и тем, что длина вектора не изменяется.

\subsubsection{permute}
Эта команда переставляет элементы вектора. Вектор делится на блоки, размером по RS байтов каждый. Размер блока должен быть степенью двойки и кратен размеру операнда. Элементы могут произвольно меняться местами в каждом блоке, но не между блоками. Каждый элемент результирующего вектора является копией элемента входного вектора, выбранного соответствующим индексом в индексном векторе. Индексы отсчитываются от начала того блока, которому принадлежат, так что индекс, равный нулю, выберет первый элемент блока входного вектора, и вставит его в соответствующую позицию результирующего вектора. Один и тот же элемент входного вектора может быть скопирован во много элементов результирующего вектора. Индекс, находящийся вне диапазона, в качестве результата даст нуль. Индексы интерпретируются как целые числа, независимо от типа операнда.

У команды permute есть две версии. Первая версия указывает индексы в векторе той же длины и того же размера элемента, что и входной вектор.

Вторая версия указывает индексы как 32--разрядную непосредственно заданную константу, с 4 разрядами на элемент. Эта константа  разбивается на самое большее 8 элементов, по 4 разряда в каждом. Если блоки имеют более 8 элементов, то, для заполнения блока, последовательность из 8 элементов повторяется. В этой версии команды permute один и тот же шаблон индексов будет применён ко всем блокам.

Максимальный размер блока для команды permute зависит от реализации и задаётся специальным регистром. Причина этого ограничения на размер блока состоит в том, что сложность аппаратуры растёт квадратично с ростом размера блока. Полная перестановка возможна, если длина вектора не превышает максимального размера блока. Если RS больше максимального размера блока, то порождается ловушка.

Есть два способа комбинирования результатов многократных команд перестановки. Один метод заключается в использовании находящихся вне диапазона индексов, чтобы порождать нули для неиспользуемых элементов, а затем применять операцию поразрядного ИЛИ результатов. Другой метод состоит в использовании масок для комбинирования результатов.

Команды перестановки полезны для переупорядочивания данных, транспонирования матриц, и т.п.

Когда размер блока достаточно велик, чтобы содержать всю таблицу, команды перестановки могут также использоваться для параллельного просмотра таблицы.

Наконец, команды перестановки могут использоваться для сбора и рассеивания данных в пределах области, не большей длины вектора или размера блока.

\subsubsection{broadcast}
Копирует первый элемент входного вектора во все элементы выходного вектора. Если максимальная длина вектора более 16 байт, то поддерживается размер элемента, равный 16 байтам (128 разрядов), даже если этот размер никак иначе не поддерживается.

\subsection{Иные одноформатные векторные команды}
\subsubsection{Арифметика с насыщением} \label{saturatedArithmeticInstructions}
Сюда относятся команды add\_ss, add\_us, sub\_ss, sub\_us, mul\_ss, mul\_us, shl\_ss, shl\_us.

Эти команды используются для арифметических операций с насыщением. Выход за верхнюю границу даст максимальное значение для заданного размера операнда. Выход за нижнюю --- минимальное значение

Поддержка данных команд необязательна.

\subsubsection{Сложение с переносом и вычитание с заёмом} \label{addWithCarryInstruction}
Это команды add\_c, sub\_b. В них dest и src1 являются векторами из двух целых чисел, а src2 --- вектор из целых чисел, в котором используется только первый элемент.

add\_c: 
\begin{verbatim}
   sum = src1[0] + src2[0] + (src1[1] & 1)
   dest[0] = bit 0-63 of sum 
   dest[1] = bit 64 of sum
\end{verbatim}

sub\_b:
\begin{verbatim}
   sum = src1[0] - src2[0] - (src1[1] & 1)
   dest[0] = bit 0-63 of sum 
   dest[1] = bit 64 of sum
\end{verbatim}

Поддержка этих команд необязательна. Более длинные векторы --- не поддерживаются. См. с.~\pageref{highPrecisionArithmetic} по поводу иных вариантов для более длинных векторов.

\subsubsection{Арифметические команды с проверкой переполнения} \label{instructionsWithOverflowCheck}
Это команды add\_oc, sub\_oc, subr\_oc, mul\_oc, div\_oc.

Данные команды для арифметических вычислений используют элементы векторов, имеющие чётные номера. Каждый следующий элемент вектора, имеющий нечётный номер, используется для обнаружения переполнения. Если первый операнд--источник является скаляром, то результирующий операнд будет вектором из двух элементов.

Условия переполнения указываются следующими разрядами:

разряд №0. беззнаковое целочисленное переполнение(перенос)

разряд №1. знаковое целочисленное переполнение

разряд №2. вещественное переполнение

разряд №3. недопустимая вещественная операция

Значения распространяются так, чтобы к результат переполнения операции и обоим входным операндам применяется поразрядное ИЛИ.

Данные команды необязательны.

\subsubsection{Расширенное деление} \label{extendedDivisionInstruction}
Это команды div\_ex\_s, div\_ex\_u.

Они необязательны, и могут поддерживаться и для скаляров, и для векторов; только для скаляров; или не поддерживаться вовсе.

\subsubsection{byte\_reverse}
Данная команда обращает порядок байтов в целом числе. Она может использоваться при чтении и записи двоичных файлов данных с обратным порядком байтов.

\subsubsection{read\_spev}
Значение поля RT указывает специальный регистр, который нужно прочитать. Приёмник является векторным регистром, длина которого указана в RS.

На данный момент определены следующие специальные регистры:

\begin{longtable} {|p{20mm}|p{130mm}|}
\caption{Специальные регистры, которые можно прочесть в векторы} 
\label{table:specialVectorRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Номер специального регистра & \bfseries Смысл  \\ \hline
0                                     & Численный управляющий регистр (NUMCONTR). Это значение рассылается во все элементы регистра--приёмника с указанными размером операнда и длиной.  \\ \hline
1                                     & Имя процессора. Результат является заканчивающейся нулём строкой в кодировке UTF-8, содержащей торговую марку и имя модели микропроцессора. \\ \hline
\end{longtable}

\subsubsection{replace}
Все элементы из src1 заменяются целочисленной или вещественной константой из src2.

При использовании без маски константа просто рассылается, чтобы сделать вектор того же размера, что и src1. При использовании с маской элементы из src1 заменяются выборочно. В зависимости от разряда №1 маски, невыбранные элементы обнуляются или остаются без изменений.

\subsubsection{make\_mask}
Сделать маску из разрядов 32--разрядной целочисленной константы src2. Каждый разряд из src2 идёт в разряд №0 одного элемента результата. Оставшиеся разряды каждого элемента берутся из src1. Длина результата --- та же, что и у src1. Если в векторе более 32 элементов, то двоичный шаблон из src2 повторяется..

\subsubsection{fp\_category}
Входной аргумент --- вещественный вектор. Выходной --- булев вектор, указывающий, принадлежит ли входной аргумент какой--либо из указанных разрядами непосредственно заданного операнда категорий:

\begin{longtable} {|l|p{90mm}|}
\caption{Смысл разрядов в fp\_category} 
\label{table:fpCategoryInstructionBits} \\
\endfirsthead
\endhead
\hline
\bfseries Номер разряда & \bfseries Смысл  \\ \hline
0 & Инвертировать результат. \\
1 & Ноль. \\
2 & Денормализованное.  \\
3 & Нормализованное. \\
4 & Бесконечность.  \\
5 & Нечисло (NAN). \\
6 & Знаковый разряд.  \\
7 & Копировать оставшиеся разряды из маски или численного управляющего регистра.  \\ \hline
\end{longtable}

\subsubsection{Команды для таблиц истинности} \label{truthTableFunctions}
Это команды truth\_tab2, truth\_tab3, truth\_tab4.

Эти команды могут вычислять заданные таблицами истинности произвольные булевы функции двух, трёх, или четырёх входных векторных булевых аргументов. Результат в разряде №0 каждого элемента вектора является произвольной булевой функцией разряда №0 соответствующих элементов каждого из входных операндов. Разряд №0 результата равен разряду из таблицы истинности, выбранному скомбинированными разрядами аргументов. Остальные разряды вектора--результата копируются из регистра маски, если таковой есть, или, в противном случае, из первого входного операнда. 

У truth\_tab2 аргументы --- в RD и RS, результат --- в RD, а 4--разрядная таблица истинности --- в IM1.

У truth\_tab3 аргументы --- в RS, RT и RU, результат --- в RD, а 8--разрядная таблица истинности --- в IM2.

У truth\_tab4 аргументы --- в RD, RS, RT и RU, результат --- в RD, а 16--разрядная таблица истинности --- в IM2.

У truth\_tab4 размер операнда должен быть не менее 16 разрядов. Команды truth\_tab3 и truth\_tab4 --- необязательны.

Команды truth\_tab3 и truth\_tab4 в качестве дополнительного операнда могут использовать маску, в соответствии с обычной функцией последней.

Эти команды могут использоваться в качестве универсальных команд для манипулирования и комбинирования булевых векторов и масок.

Аппаратная реализация может использовать существующие модули сдвига, сдвигая таблицу истинности на количество разрядов, указанное скомбинированными разрядами входных операндов.

\subsubsection{add\_add\_add} \label{addAddAdd}
Складывает четыре аргумента. Последний операнд может быть регистровым операндом или 16--разрядным знаковым непосредственно заданным операндом. Знаки операндов могут инвертироваться, что указывается разрядами 0--3 поля OP3:

разряд №0: изменить знак src1

разряд №1: изменить знак src2

разряд №2: изменить знак src3

разряд №3: изменить знак src4

По поводу деталей см. с.~\pageref{addAdd}.

Данная команда --- необязательна.

\section{Распространённые операции, для которых нет специальных команд}
В данном разделе обсуждаются некоторые распространённые операции, которые не реализованы как отдельные команды, и то, как закодировать эти операции программно.

\subsubsection{Смена знака}
Для целочисленных операндов осуществляйте её обратным вычитанием из нуля. Для вещественных операндов используйте команду toggle\_b над знаковым разрядом.

\subsubsection{Команда abs для вещественных чисел}
Для получения абсолютной величины вещественного числа используйте clear\_b для очистки знакового разряда.

\subsubsection{Not}
Чтобы инвертировать все разряды целого числа, выполните ИСКЛЮЧАЮЩЕЕ ИЛИ с -1. Для инвертирования булева значения выполните ИСКЛЮЧАЮЩЕЕ ИЛИ с 1.

\subsubsection{Вращение через перенос}
Вращение через перенос используется редко, а распространённые реализации могут быть очень неэффективны. Вращение влево через перенос можно заменить командой  add\_c с одним и тем же регистром в обоих операндах--источниках.

\subsubsection{Горизонтальное векторное сложение} \label{horizontalVectorAdd}
Команда сложения всех элементов вектора была бы полезна, но такая команда не поддерживается, ибо такая она была бы сложной командой с переменной задержкой, зависящей от длины вектора.

Сумму всех элементов вектора можно вычислить, повторно складывая младшую и старшую половины вектора. Данный метод иллюстрируется следующим примером, находящим горизонтальную сумму вектора, состоящего из 32--разрядных целых чисел. Синтаксис языка ассемблера описан на с.~\pageref{assemblySyntax}.
\begin{verbatim}
   v0 = my_vector   // мы хотим вычислить горизонтальную сумму этого вектора
   r0 = get_len(v0) // длина вектора (в байтах)
   r0 = roundu2.64(r0)  // округлить к ближайшей большей степени двойки
   v0 = set_len(v0, r0) // настроить длину вектора
   // Цикл вычисления горизонтальной суммы для v0
   LOOP: // метка
      // Вектор половинной длины.
      r1 = shift_rightu.64(r0, 1)
      // Получить старшую половину вектора.
      v1 = shift_reduce(v0, r1)
      // Сложить старшую и младшую половины
      v0 = add.32(v1, v0)  // результат имеет ту же длину, что и первый операнд
      // Половинная длина для следующей операции.
      r0 = r1
      // повторять, пока вектор содержит более одного элемента
      compare_unsign_jmpabove(r1, 4, LOOP)      
   // Теперь сумма является скаляром, находящимся в v0.
\end{verbatim}

Тот же самый метод может использоваться и для других горизонтальных операций. Может вызвать проблемы то, что команда set\_len вставляет равные нулю элементы, если длина вектора не равна степени двойки. Особенно беспокоиться нужно, если операция не допускает равных нулю дополнительных элементов, например, если операция использует умножение или нахождение наименьшего элемента. Возможное решение состоит в маскировании неиспользуемых элементов на первой итерации. Следующий пример находит наименьший элемент в векторе из вещественных чисел:
\begin{verbatim}
   v0 = my_vector              // найти наименьший элемент в этом векторе
   r0 = get_len(v0)            // длина вектора (в байтах)
   r1 = roundu2.64(r0)         // округлить к ближайшей большей степени двойки
   r1 = shift_rightu.64(r1, 1) // половина длины
   v1 = shift_reduce(v0, r1)   // старшая часть вектора
   r2 = sub.64(r0, r1)         // длина вектора v1
   // использовать маску, поскольку два операнда могут иметь различные длины
   v0 = set_len(v0, r1)        // уменьшить длину вектора v0
   v2 = v0                     // произвольный вектор с длиной r1
   v2 = mask_length.32(v2, r2, 0x22)  // создать маску для v1
   v0 = min.f(v0, v1, mask=v2) // получить минимум, замаскировав неиспользуемые элементы
   cmp_unsign_jmpbeloweq(r1, 4, ENDOFLOOP) // проверить, не закончилось ли уже
   // Цикл для вычисления горизонтального минимума из элементов v0.
   LOOP: // метка
      // Вектор половинной длины.
      r2 = shift_rightu.64(r1, 1)
      // Получить старшую половину вектора.
      v1 = shift_reduce(v0, r2)
      // Вычислить минимум из старшей и младшей половины.
      v0 = min.f(v1, v0)  // результат имеет ту же длину, что и первый операнд
      // Половинная длина для следующей операции.
      r1 = r2
      // повторять, пока вектор содержит более одного элемента
      compare_unsign_jmpabove(r2, 4, LOOP)
   ENDOFLOOP:      
   // Теперь минимум является скаляром, находящимся в v0.
\end{verbatim}

\subsubsection{Арифметика высокой точности} \label{highPrecisionArithmetic}
Библиотеки функций для арифметики высокой точности для сложения чисел с очень большим количеством разрядов обычно используют длинную последовательность команд сложения с переносом. Более эффективным методом для вычислений с большими числами является использование векторного сложения и метода ускоренного переноса. Следующий алгоритм вычисляет A + B, где A и B --- большие целые числа, представленные в виде двух векторов, по n$\cdot$64 разрядов в каждом, где n \textless{} 64.
\begin{verbatim}
v0 = A                   // первый вектор, n*64 bits
v1 = B                   // второй вектор, n*64 bits
v2 = carry_in            // скаляр в векторном регистре
v0 = add.64(v0, v1)      // сумма без промежуточных переносов
v3 = compare.64(v0,v1,8) // породить перенос = (SUM < B) (сравнение --- беззнаковое)
v4 = compare.64(v0,-1,0xA) // распространить перенос = (SUM == -1) 
v3 = bool2bits(v3)       // породить перенос, сжатый до битового поля
v4 = bool2bits(v4)       // породить перенос, сжатый до битового поля
// CA = CP ^ (CP + (CG<<1) + CIN) // распространить дополнительный перенос
v3 = shift_left.64(v3,1) // сдвинуть влево порождённые переносы
v2 = add.64(v2,v4)
v2 = add.64(v2,v3)
v2 = xor.64(v2,v4)
v1 = bits2bool(v2)       // расширить дополнительный перенос на вектор
v0 = sum.64(v0,v1)       // прибавить поправку к сумме
r0 = get_num(v0)         // n = количество элементов в векторах
v3 = gp2vec.64(r0)       // копировать в векторный регистр
v2 = shift_rightu.64(v2,v3) // итоговый перенос
// v0 = сумма, v2 = итоговый перенос
\end{verbatim}

Если числа A и B длиннее, чем максимальная длина вектора, то алгоритм повторяется. Если длина вектора --- больше, чем 64 $\cdot$ 8 байт, то вычисление дополнительного переноса вовлечёт более 64 разрядов, что снова потребует алгоритма работы с большими числами.

\section{Неиспользуемые команды} \label{unusedInstructions}
Неиспользуемые команды и опкоды (коды операций) можно разбить на три типа:
\begin{enumerate}
	\item Опкод зарезервирован для последующего использования. Попытка его выполнения вызовет ловушку (синхронное прерывание), которая может использоваться для порождения сообщения об ошибке или для эмуляции неподдерживаемой команды.
	\item Опкод гарантированно генерирует ловушку, не только в текущей версии, но и всех последующих. Он может использоваться как заполнитель неиспользуемых частей памяти или как указание на ошибку, после которой невозможно восстановиться. Его можно также использовать для эмуляции специфичных для пользователя команд.
	\item Ошибка игнорируется, и ловушки не возникает. Это может использоваться для последующих расширений, улучшающих производительность или функциональность, но которые можно безопасно игнорировать, когда они не поддерживаются.
\end{enumerate}

Реализованы все три типа, и тип 1 --- наиболее распространён.

Команды nop с ненулевыми значениями в неиспользуемых полях принадлежат типу 3. Эти команды игнорируются.

Команды prefetch и fence без находящегося в памяти операнда, с ненулевыми значениями в неиспользуемых полях, или с неопределёнными значениями в OP3 принадлежат типу 3. Эти команды игнорируются.

Неиспользуемые разряды в масках и численном управляющем регистре имеют тип 3. Эти разряды игнорируются.

Команды trap (в том числе условные) с ненулевыми значениями в неиспользуемых полях или неиспользуемыми значениями в любом поле имеют тип 2. Эти команды гарантированно порождают ловушку. Специальная версия команды trap предназначена для использования в качестве заполнителя неиспользуемых или недоступных частей памяти кода.

Команда undef имеет тип 2. Она гарантированно порождает ловушку на всех системах, и может использоваться для целей тестирования и эмуляции.


Команды userdef\_\_ имеют тип 1. Эти команды зарезервированы для определения пользователем и для целей конкретных приложений.

Для команд с ошибочной кодировкой следует предпочесть их поведение, как в типе 1. Сюда включаются коды команд с ненулевыми значениями в неиспользуемых полях, неподдерживаемыми типами операндов, или любыми другими двоичными шаблонами с неопределённым смыслом в каком--либо поле. Как вариант, в этих случаях может допускаться поведение типа 3. Если это так, то команде следует вести себя так, как будто она закодирована корректно.

Все прочие опкоды неявно определены как имеющие тип 1, и могут использоваться для последующих расширений.

Малым системам, без операционных систем и без поддержки ловушек, следует определить иное поведение. 
\end{document}