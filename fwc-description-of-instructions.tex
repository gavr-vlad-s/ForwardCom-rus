% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}

\section{Описание команд}
В данном разделе описываются команды, для которых нужны специальные объяснения.

\subsection{Многоформатные команды}
\subsubsection{nop}
Рекомендуется кодировать команды NOP в виде 32--разрядного слова, все разряды которого равны нулю. Процессору разрешается пропускать такого рода команды NOP на ранней стадии конвейера, и настолько быстро, насколько он может. Пара малых команд, в которой вторая команд --- NOP, может рассматриваться как одна команда.

Эти команды NOP могут использоваться только как заполнители, но не для задержек.

\subsubsection{move}
Копирование значения из находящегося в памяти операнда, регистра, или непосредственно заданной константы в регистр. Если приёмник --- векторный регистр, а источник --- непосредственно заданная константа, то результат будет скаляром. Значение размножено не будет, поскольку нет никакого иного входного операнда, который бы указывал длину вектора. Если желателен вектор, то используйте команду broadcast.

Команда move с непосредственно заданным операндом  --- предпочтительный метод обнуления регистра.

Команда move  имеет несколько дополнительных малых и одноформатных вариантов. Ассемблер, как правило, выберет самый короткий вариант, в который помещаются указанные операнды.

\subsubsection{store}
Операнды--источники и операнды--приёмники меняются ролями, так что значение из RD записывается в находящийся в памяти операнд. Допускаются только форматы, которые указывают находящийся в памяти операнд (скалярный, либо векторный без размножения).

Размер находящегося в памяти операнда определяется полем размера операнда (OS), когда указан находящийся в памяти скалярный операнд, или длиной векторного регистра в RS, когда указан находящийся в памяти векторный операнд.

Аппаратура должна быть в состоянии обрабатывать размеры находящихся в памяти операндов, не являющиеся степенями двойки, не используя при этом дополнительной памяти (чтение и перезапись за пределами находящегося в памяти операнда --- не допускаются, разве что обращение из других потоков блокировано во время выполнения операции, и подавляются исключения отсутствия доступа). Разрешается записывать операнд по кусочкам.

Замаскированная операция с разрядами маски №№ 0 и 1, равными нулю одновременно, запишет в память ноль.

Замаскированная операции с разрядом №0, равным 0, и разрядом №1, равным единице, для векторных регистров может поддерживаться, а может и не поддерживаться. Если поддерживается, то эта комбинация оставит ячейку памяти без изменения, и не может быть реализована как чтение, совмещённое с записью, поскольку это не было бы потокобезопасно.

\subsubsection{prefetch}
Предвыборка находящегося в памяти операнда в кэш. Разные варианты могут указываться разрядами №№0--3 поля OP3 форматов 2.4 и 2.8.

\subsubsection{sign\_extend}
Входным операндом может быть 8--разрядное, 16--разрядное, или 32--разрядное целое число. Это целое число расширяется знаком, чтобы получить 64--разрядный результат в регистре общего назначения или скаляр в векторном регистре. Если входной операнд --- вектор, то в каждом 64--разрядном блоке используется только первый элемент. Вещественные типы использоваться не могут.

\subsubsection{min and max}
min(src1,src2) = src1 \textless{} src2 ? src1 : src2

max(src1,src2) = src1 \textless{} src2 ? src1 : src2

Операнды рассматриваются как знаковые. Есть также версия для беззнаковых целых:

min\_u(src1,src2) = src1 \textless{} src2 ? src1 : src2

max\_u(src1,src2) = src1 \textless{} src2 ? src1 : src2

Когда беззнаковая версия применяется к вещественным операндам, она берёт абсолютные величины операндов, и имя команды изменяется:

min\_abs(src1, src2) = min(abs(src1), abs(src2))

max\_abs(src1, src2) = max(abs(src1), abs(src2))

Обработка вещественных операндов, являющихся нечислами (NAN), определяется разрядом №22 регистра маски или вещественного управляющего регистра. Если разряд №22 равен нулю, то, в соответствии с  IEEE Standard 754-2008, результатом является не являющийся нечислом операнд. Если разряд №22 равен единице, то входной операнд, являющийся NAN, распространяется дальше.

Являющийся NAN операнд, который не является распространяемым, породит ловушку, если установлен флаговый разряд №29.

\subsubsection{Поразрядные логические команды}
Это следующие команды: and, and\_not, or, xor. Вещественные операнды обрабатываются точно так же, как и целочисленные.

\subsubsection{Команды манипуляции разрядами}
Для манипуляции разрядами предоставляются следующие команды: 

extract\_b: выделить разряд с номером src2 из src1

set\_b: заменить в src1 разряд с номером src2 на 1

clear\_b: заменить в src1 разряд с номером src2 на 0

toggle\_b: инвертировать в src1 разряд с номером src2

Вещественный операнд в src1 рассматривается как целое число такого же размера. Индекс разряда в src2, независимо от типа операнда, интерпретируется как 8--разрядное беззнаковое целое число.

Эти команды могут быть реализованы с 8--разрядной непосредственно заданной константой для src2, вместо большей константы, которая потребовалась бы, если бы мы использовали команды AND, OR, XOR для манипулирования одиночными разрядами. Эти команды могут также использоваться с вещественными числами, в основном для манипулирования знаковым разрядом.

\subsubsection{mul\_add}
Совмещённые умножение и сложение.

dest = $\pm$ src1 $\pm$ (src2 $\cdot$ src3)

Команда совмещённого умножения и сложения часто может значительно улучшить производительность вещественного кода.

Поддерживаются только форматы, допускающие три операнда.

Знаки операндов могут быть изменены, что указывается в разрядах №№0--3 поля OP3 в форматах, использующих шаблон E2, включая дополнительный формат 2.5, при этом

разряд 0: изменить знак у элементов вектора src1 с чётными номерами

разряд 1: изменить знак у элементов вектора src1 с нечётными номерами

разряд 2: изменить знак у элементов вектора src2$\cdot$src3  с чётными номерами

разряд 3: изменить знак у элементов вектора src2$\cdot$src3  с нечётными номерами

Команда делает возможным выполнение умножения--и--сложения, умножения--и--вычитания, умножения--и обратного--вычитания, и т.п. Можно также выполнять умножение с чередующимися сложением и вычитанием, что полезно при вычислениях с комплексными числами. В других форматах, в которых поле OP3 отсутствует, смены знака нет. Поддерживается дополнительная одноформатная версия mul\_add, с четырьмя регистровыми операндами и полем OP3.

Поле OP3 не используется как счётчик сдвига в форматах 2.5 и 2.9.

Поддержка целочисленных операндов --- необязательна. Поддержка вещественных операндов --- необязательна, но желательна.

\subsubsection{add\_add}  \label{addAdd}
Два сложения в одной команде.

dest = $\pm$ src1 $\pm$ src2 $\pm$ src3

Поддерживаются только форматы, допускающие три операнда.

Знаки операндов могут быть изменены, что указывается в разрядах №№0--2 поля OP3 в форматах, использующих шаблон E2, включая дополнительный формат 2.5, при этом

bit 0: изменить знак src1

bit 1: изменить знак src2

bit 2: изменить знак src3

В других форматах, в которых поле OP3 отсутствует, смены знака нет. Поддерживается дополнительная одноформатная версия add\_add, с четырьмя регистровыми операндами и полем OP3. 

Поле OP3 не используется как счётчик сдвига в форматах 2.5 и 2.9.

Желательна точность вещественных операндов, меньшая единицы самого младшего разряда численно самого большого операнда, но промежуточный результат не вычисляется с неограниченной точностью. Аппаратная реализация может подстроить экспоненты для всех операндов за первый такт, и использовать сеть сумматора цепи умножения.

Данную команду следует поддерживать, только если её можно реализовать так, чтобы она была быстрее двух последовательных команд сложения. Она может поддерживаться для целочисленных операндов, вещественных операндов, или и для тех, и для других. См. также команду add\_add\_add (с.~\pageref{addAddAdd}).

\subsubsection{Команды сравнения}
Команда сравнения сравнивает два операнда--источника и сохраняет результат в разряде №0 приёмника. Когда используются форматы 0.0-0.3 или 2.0-2.3, условие определяется добавочным кодом, сохранённым в третьем операнде--источнике. Форматы, использующие шаблон E2 (2.4, 2.5, 2.8, 2.9) кодируются иначе: код условия содержится в поле OP3. Шестнадцатиразрядное поле IM2 форматов  2.5 и 2.9 используется как второй операнд--источник, который не сдвигается на  OP3.

Оставшиеся разряды результата копируются из регистра маски, или из численного управляющего слова, если маска не используется. Это подходит, когда результат используется как маска.

Коды условий определены в следующей таблице:

\begin{longtable} {|l|p{100mm}|}
\caption{Коды условий для команд сравнения} 
\label{table:conditionCodesForCompareInstruction} \\
\endfirsthead
\endhead
\hline
\bfseries Разряд & \bfseries Смысл      \\ \hline
0                & Инвертирует условие. \\ \hline
1-2              & Определяет условие: \newline
				      0 = меньше,\newline
				      1 = равно,\newline
				      2 = больше,\newline
				      3 = неупорядочено.         \\ \hline
3   			& Для целочисленных операндов: \newline
			      0 = знаковые операнды,\newline
			      1 = беззнаковые операнды.\newline
			      Для вещественных операндов:\newline
			      данный разряд указывает результат, если один операнд, либо оба, являются нечислами (NAN). \\ \hline
\end{longtable}

Команды сравнения могут быть замаскированы. Разряд №0 результата равен разряду №1 регистра маски, если разряд №0 регистра маски равен нулю.

\subsection{Команды малого формата}
\subsubsection{clear}
Данная команда устанавливает длину векторного регистра равной нулю. Всё содержимое теряется. Регистр может затем рассматриваться как неиспользуемый.

\subsubsection{Операции push и pop}
Команд push и pop нет. Регистр общего назначения R можно втолкнуть в стек с помощью следующей пары малых команд:
\begin{verbatim}
    add sp,-8
    store [sp],R
\end{verbatim}

Регистр общего назначения R можно вытолкнуть из стека с помощью следующей пары малых команд:
\begin{verbatim}
    move R,[sp] 
    sub sp,-8
\end{verbatim}
Обратите внимание, что константа -8 может содержаться в 4--разрядном знаковом поле RS, а константа 8 --- нет. Именно по этой причине мы прибавляем и вычитаем -8, а не выполняем обратные операции с +8.

Для этих последовательностей ассемблер может поддерживать макросы с именами push и pop.

\subsubsection{Сохранение и восстановление векторных регистров} \label{saveRestoreVectorRegisters}
При сохранении векторного регистра переменной длины мы не хотим сохранять максимальную длину, когда используется только часть регистра. Как следствие, вы имеем команды save\_cp и restore\_cp, предназначенные для сохранения и восстановления векторных регистров без использования большего объёма памяти, нежели необходимо.

Обратите внимание, что формат сохранённого образа зависит от реализации. Как правило, команда save\_cp сохранит длину вектора, за которой  следует столько байтов, сколько указано длиной, а команда restore\_cp прочтёт длину, а затем прочтёт столько байтов, сколько указано длиной.

Микропроцессору разрешается сжимать данный любым способом, который можно обработать достаточно быстро. Например, булев вектор, использующий только один разряд в каждом элементе, может, очевидно, быть сжат до гораздо меньшего размера. Образ неиспользуемого векторного регистра будет, как правило, содержать несколько нулевых байтов для длины.

Программному обеспечению никогда не следует использовать сохранённый образ ни для чего иного, нежели восстановление векторного регистра на той же модели микропроцессора, что сохранила его, поскольку формат образа несовместим у разных моделей.

Размер сохранённого образа можно прибавить к указателю командой add\_cps или вычесть из указателя командой sub\_cps. Поле RS задаёт указатель, которым может быть r0--14 или r31 (указатель стека).

Векторный регистр V можно сохранить в стеке (втолкнуть в стек) с помощью следующей пары малых команд: 
\begin{verbatim}
   sub_cps sp,V
   save_cp [sp],V
\end{verbatim}

Векторный регистр V можно восстановить из стека (вытолкнуть) с помощью следующей пары малых команд:
\begin{verbatim}
   restore_cp V,[sp]
   add_cps sp,V
\end{verbatim}

Те же команды можно использовать для сохранения регистров при переключении задач. При сохранении таким способом, неиспользуемые векторные регистры будут использовать очень мало места.

Размер сжатого образа, указываемого командами add\_cps и sub\_cps, при использовании указателя стека должен быть кратным 8, чтобы сохранить должное выравнивание стека. 

При переключении задач, когда, как правило, используется другой указатель команд, разрешается использовать меньший размер, не кратный 8. В этом случае для управления форматом сохранённого образа должен быть предоставлен управляющий регистр.

Команде restore\_cp разрешается читать больше байтов, чем необходимо, вплоть до значения, равного максимальной длине вектора плюс 8 байт, и отбрасывать впоследствии, когда станет известна действительная длина, любые избыточные байты.

\subsection{Одноформатные команды, использующие регистры общего назначения и специальные регистры}
\subsubsection{read\_spe, write\_spe}
Чтение или запись специального регистра. Ниже указаны определённые на данный момент специальные регистры. Разрядность каждого равна 64. Эти регистры инициализируются их принятыми по умолчанию значениями в момент запуска программы.

\begin{longtable} {|l|l|}
\caption{Список специальных регистров} 
\label{table:specialRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Номер специального регистра & \bfseries Смысл  \\ \hline
0                                     & Численный управляющий регистр (NUMCONTR).  \\
1 									  & Идентификатор (ID) марки микропроцессора  \\
2                                     & Номер версии микропроцессора.   \\
28                                    & Указатель блока окружения потока (THREADP).   \\
29                                    & Указатель секции данных (DATAP).  \\
\hline
\end{longtable}

\subsubsection{read\_cpb, write\_cpb}
Чтение или запись регистра возможностей процессора. Эти регистры используются для указания возможностей процессора, таких, как поддержка необязательных команд и ограничения на длину вектора. Разрядность такого регистра равна 64. В момент запуска программы эти регистры инициализируются принятыми для них по умолчанию значениями.

Находящаяся в IM1 непосредственно заданная константа определяет детали операции:

\begin{longtable} {|p{20mm}|p{128mm}|}
\caption{Смысл непосредственно заданной константы в командах read\_cpb и write\_cpb} 
\label{table:readWriteCpbModes} \\
\endfirsthead
\endhead
\hline
\bfseries Номер разряда & \bfseries Смысл  \\ \hline
0                       &  0: чтение/запись возможностей для типа операнда, указанного в разрядах №№5-7.\newline
                           1: чтение типичных возможностей для всех типов операндов / запись возможностей для всех соответствующих типов операндов.  \\ \hline
1                       &  0: чтение текущего значения регистра, которое, возможно, изменено.\newline
                           1: чтение реальных возможностей аппаратуры (записывать нельзя). \\ \hline
5-7                     & Тип операнда для возможностей. \\ \hline
\end{longtable}

\begin{longtable} {|p{20mm}|p{110mm}|}
\caption{Список регистров возможностей} 
\label{table:capabilitiesRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Номер регистра возможностей & \bfseries Смысл  \\ \hline
0  &  Максимальная длина вектора для команд общего назначения. \\ \hline
1  &  Максимальная длина вектора для команд перестановки. \\ \hline
2  &  Максимальная длина блока для команд перестановки. \\ \hline
3  &  Максимальная длина вектора для compress\_sparse и expand\_sparse. \\ \hline
8  &  Поддержка необязательных команд, работающих с регистрами общего назначения. Каждый разряд отвечает за свою команду. \\ \hline
9  &  Поддержка необязательных команд, работающих со скалярами в векторных регистрах. Каждый разряд отвечает за свою команду.  \\ \hline
10 &  Поддержка необязательных команд, работающих с векторами. Каждый разряд отвечает за свою команду.  \\ \hline
\end{longtable}

Изменение значений максимальной длины вектора оказывает следующее влияние. Если максимальная длина уменьшается до величины, меньшей физически возможной, то любая попытка сделать более длинный вектор даст вектор с уменьшенной длиной. Поведение векторных регистров, у которых до уменьшения максимальной длины уже была большая длина, зависит от реализации. Если максимальная длина устанавливается равной значению, которое больше физически возможного, то любая попытка сделать вектор размера, большего физически возможного, вызовет ловушку, для облегчения эмуляции. Регистры возможностей с номерами 0--3 для целей эмуляции могут быть увеличены. Значение регистров возможностей с номерами 0--3 должно быть степенью двойки.

Регистры возможностей с номерами 8--9 могут модифицироваться, для тестовых целей или для того, чтобы сообщить программному обеспечению: \glqq не используй конкретные команды\grqq. То же значение будет возвращаться при чтении регистра. Попытка выполнить неподдерживаемую команду вызовет ловушку, независимо от значения регистра возможностей.

\subsubsection{read\_sys, write\_sys}
Эти команды предназначены для обращения к различным регистрам, доступным только для чтения.

\subsubsection{read\_perf}
Прочесть внутренний счётчик тактов, количество выполненных команд, или иные связанные с производительностью счётчики.

\subsubsection{read\_perfs}
То же, что и read\_perf. Данная команда сериализуется. Это означает, что она не может выполняться неупорядоченно.

\subsubsection{popcount}
Команда popcount считает количество единичных разрядов в целом числе. Она может также использоваться для генерирования чётности.

\subsubsection{bitscan\_f}
Сканировать разряды вперёд.

Найти индекс самого младшего единичного разряда, т.е. наибольшее  X, для которого

(((1 $\ll$ X) - 1) \& src1)) == 0.

\subsubsection{bitscan\_r}
Сканировать разряды назад.

Найти индекс самого старшего единичного разряда, т.е. наибольшее  X, для которого (1 $\ll$ X) $\leq$ src1.

\subsubsection{round\_d2}
Округлить к ближайшей степени двойки, т.е. 1 $\ll$ bit\_scan\_reverse(src1).

\subsubsection{round\_u2}
Округлить к ближайшей большей степени двойки, т.е.

(S \& (S-1)) == 0 ? S : 1 $\ll$  (bit\_scan\_reverse(S) + 1),

где S = src1.

\subsubsection{shift\_add}
Сдвинуть и сложить, dest = src1 + (src2 $\ll$  src3); src1 использует тот же регистр, что dest; src3 --- 8--разрядная знаковая непосредственно заданная константа.

Если src3 --- отрицательно, то будет выполняться сдвиг вправо.

\subsubsection{address}
Вычислить адрес относительно указателя, сложив 32--разрядную расширенную знаком константу с регистром общего назначения или специальным регистром. Регистром--указателем может быть r0-r27, THREADP (28), DATAP (29), IP (30) или SP(31).

\subsubsection{cmp\_swap}
Команда атомарного сравнения и обмена, используемая для синхронизации и безблокировочного разделения данных между потоками; src1 и src2 --- регистровые операнды; src3 --- находящийся в памяти операнд, который должен быть выровнен по естественному адресу. Все операнды рассматриваются как целочисленные, независимо от указанного типа операнда. Операция выполняется так:
\begin{verbatim}
   temp = src3;
   if (temp == src1) src3 = src2;
   return temp;
\end{verbatim}

Если необходимо, могут быть реализованы и другие атомарные команды (в формате 2.8 с OP1 = 1 и увеличивающимися значениями в OP2).

\subsection{Одноформатные команды с РОН в качестве входного операнда и векторным регистром в качестве выходного, или наоборот}
\subsubsection{gp2vec}
Значение регистра общего назначения копируется в находящийся в векторном регистре скаляр. Длина будет равна размеру операнда. Никаких преобразований типа не выполняется.

\subsubsection{vec2gp}
Первый элемент векторного регистра копируется в регистр общего назначения. Если указан целочисленный тип, имеющий разрядность, меньшую 64, то значение знаком расширяется до 64 разрядов. Если указан тип \glqq вещественное число одинарной точности\grqq, то значение расширяется нулём до 64 разрядов. Никаких иных преобразований типов не выполняется.

\subsubsection{set\_len}
Устанавливает длину векторного регистра равной количеству байт, указанному в регистре общего назначения. Если указанная длина больше длины, максимально допустимой для указанного типа операнда, то будет использоваться максимальная длина.

Если выходной вектор длиннее входного, то дополнительные элементы будут нулями. Если выходной вектор --- короче входного, то лишние элементы будут отброшены.

\subsubsection{get\_len}
Получает длину векторного регистра (в байтах). Результат сохраняется в регистре общего назначения.

\subsubsection{set\_num}
То же, что и set\_len, но длина умножается на размер операнда.

\subsubsection{get\_num}
То же, что и  get\_len, но длина делится на размер операнда.

\subsubsection{mask\_length}
Сделать булев вектор, для того, чтобы замаскировать первые n элементов вектора, где n = RS / (размер операнда). Выходной вектор RD будет иметь ту же длину, что и входной вектор RD. RS указывает длину части, которая разрешается маской. IM1 содержит следующие разряды опций:\\
разряд №0 = 0: разряд №0 будет равен 1 в первых n элементах результата, и 0 --- в остальных; \\
разряд №0 = 1: разряд №0 будет равен 0 в первых n элементах результата, и 1--- в остальных; \\
разряд №1 = 1: разряд №1 всех элементов результата равен 1; \\
разряд №2 = 1: копировать разряд №1 каждого элемента из входного вектора RD; \\
разряд №3 = 1: копировать разряд №1 каждого элемента из численного управляющего регистра; \\
разряд №4 = 1: копировать оставшиеся разряды из входного вектора RD; \\
разряд №5 = 1: копировать оставшиеся разряды из численного управляющего регистра. \\
Разряды результата, не установленные никакой из этих опций, будут нулями.

\subsubsection{make\_sequence}
Сделать вектор, длина которого равна RS байтов. Количество элементов равно RS/(размер операнда). Первый элемент равен IM1, следующий элемент --- IM1+1, и т.д. Поддержка вещественных чисел --- необязательна.


\subsection{Другие одноформатные команды, которые могут изменять длину вектора}
\subsubsection{bits2bool}
Расширить смежные разряды векторного регистра до булева вектора, с одним разрядом в каждом элементе

\subsubsection{bool2bits}
Преобразовать булев вектор из n элементов в n непрерывных разрядов векторного регистра. Длина результирующего вектора будет равна степени двойки, достаточной для хранения n разрядов.

\subsubsection{shift\_expand}
Длина вектора увеличивается на указанное количество байтов, посредством сдвига всех байтов вправо и добавления нулевых младших байтов. Если получившаяся длина больше  максимальной длины вектора для указанного типа операнда, то старшие байты теряются.

\subsubsection{shift\_reduce}
Длина вектора уменьшается на указанное количество байтов, посредством сдвига всех байтов вправо. Если получившаяся длина меньше нуля, то результатом будет вектор нулевой длины. Указываемый тип операнда --- игнорируется.

\subsubsection{compress}
Элементы вектора преобразуются к элементам половинного размера. Длина результирующего вектора будет равна половине длины входного вектора. Поле OT указывает тип операнда входного вектора. Вещественные числа двойной точности преобразуются в числа одинарной точности. Целочисленные элементы преобразуются к половинному размеру отбрасыванием старших разрядов. Поддержка следующих преобразований необязательна: одинарная точность в половинную, четырёхкратная точность в двойную, 8--разрядное целое в 4--разрядное.

Если длина входного вектора отличается от длины, указанной в RS, то перед сжатием длина преобразуется к длине в RS.

\subsubsection{compress\_ss}
То же, что и compress. Целые числа трактуются как знаковые, и сжимаются с насыщением. Вещественные операнды использоваться не могут. Данная команда необязательна.

\subsubsection{compress\_us}
То же, что и compress. Целые числа трактуются как беззнаковые, и сжимаются с насыщением. Вещественные операнды использоваться не могут. Данная команда необязательна.

\subsubsection{expand}
Это операция, обратная к compress. Результирующий вектор имеет указанную длину, а входной вектор --- половинную длину. Поле OT указывает тип операнда выходного вектора. Вещественные числа одинарной точности преобразуются в числа двойной точности. Целые числа преобразуются в числа двойного размера расширением знаком. Поддержка следующих преобразований необязательна: половинная точность в одинарную, двойная точность в четырёхкратную, 4--разрядное целое в 8--разрядное.

Если длина входного вектора отличается от RS/2, то перед расширением она преобразуется. Если получившаяся длина превышает максимальную длину вектора для указанного типа операнда, то лишние элементы теряются.

\subsubsection{expand\_us}
То же, что expand. Целые числа расширяются знаком. Вещественные операнды использоваться не могут.

\subsection{Одноформатные команды, которые могут перемещать данные горизонтально из одного вектора в другой}
Для очень длинных векторов задержка этих команд может зависеть от расстояния перемещения (указанного в RS).

\subsubsection{extract}
Выделить один элемент вектора в скаляр, находящийся в векторном регистре. Находящийся вне диапазона индекс порождает нулевой результат. Может использоваться размер операнда, равный 16 байтам, даже если этот размер никак иначе не поддерживается.

\subsubsection{insert}
Заменить один элемент вектора, вставив скаляр в позицию, указанную индексом. Находящийся вне диапазона индекс оставит вектор без изменения. Может использоваться размер операнда, равный 16 байтам, даже если этот размер никак иначе не поддерживается.

\subsubsection{shift\_up}
Сдвинуть элементы вектора влево на количество элементов, указанное в RS. Младшие RS элементов приёмника становятся нулями, а старшие RS элементов источника --- теряются.

Данная команда отличается от shift\_expand тем, что величина сдвига указывается как количество элементов, а не количество байтов, и тем, что длина вектора не изменяется.

\subsubsection{shift\_dn}
Сдвинуть элементы вектора вправо на количество элементов, указанное в RS. Старшие RS элементов приёмника становятся нулями, а младшие RS элементов источника --- теряются.

Данная команда отличается от shift\_reduce  тем, что величина сдвига указывается как количество элементов, а не количество байтов, и тем, что длина вектора не изменяется.

\subsubsection{permute}
Эта команда переставляет элементы вектора. Вектор делится на блоки, размером по RS байтов каждый. Размер блока должен быть степенью двойки и кратен размеру операнда. Элементы могут произвольно меняться местами в каждом блоке, но не между блоками. Каждый элемент результирующего вектора является копией элемента входного вектора, выбранного соответствующим индексом в индексном векторе. Индексы отсчитываются от начала того блока, которому принадлежат, так что индекс, равный нулю, выберет первый элемент блока входного вектора, и вставит его в соответствующую позицию результирующего вектора. Один и тот же элемент входного вектора может быть скопирован во много элементов результирующего вектора. Индекс, находящийся вне диапазона, в качестве результата даст нуль. Индексы интерпретируются как целые числа, независимо от типа операнда.

У команды permute есть две версии. Первая версия указывает индексы в векторе той же длины и того же размера элемента, что и входной вектор.

Вторая версия указывает индексы как 32--разрядную непосредственно заданную константу, с 4 разрядами на элемент. Эта константа  разбивается на самое большее 8 элементов, по 4 разряда в каждом. Если блоки имеют более 8 элементов, то, для заполнения блока, последовательность из 8 элементов повторяется. В этой версии команды permute один и тот же шаблон индексов будет применён ко всем блокам.

Максимальный размер блока для команды permute зависит от реализации и задаётся специальным регистром. Причина этого ограничения на размер блока состоит в том, что сложность аппаратуры растёт квадратично с ростом размера блока. Полная перестановка возможна, если длина вектора не превышает максимального размера блока. Если RS больше максимального размера блока, то порождается ловушка.

Есть два способа комбинирования результатов многократных команд перестановки. Один метод заключается в использовании находящихся вне диапазона индексов, чтобы порождать нули для неиспользуемых элементов, а затем применять операцию поразрядного ИЛИ результатов. Другой метод состоит в использовании масок для комбинирования результатов.

Команды перестановки полезны для переупорядочивания данных, транспонирования матриц, и т.п.

Когда размер блока достаточно велик, чтобы содержать всю таблицу, команды перестановки могут также использоваться для параллельного просмотра таблицы.

Наконец, команды перестановки могут использоваться для сбора и рассеивания данных в пределах области, не большей длины вектора или размера блока.

\subsubsection{broadcast}
Копирует первый элемент входного вектора во все элементы выходного вектора. Если максимальная длина вектора более 16 байт, то поддерживается размер элемента, равный 16 байтам (128 разрядов), даже если этот размер никак иначе не поддерживается.

\subsection{Иные одноформатные векторные команды}
\subsubsection{Арифметика с насыщением} \label{saturatedArithmeticInstructions}
Сюда относятся команды add\_ss, add\_us, sub\_ss, sub\_us, mul\_ss, mul\_us, shl\_ss, shl\_us.

Эти команды используются для арифметических операций с насыщением. Выход за верхнюю границу даст максимальное значение для заданного размера операнда. Выход за нижнюю --- минимальное значение

Поддержка данных команд необязательна.

\subsubsection{Сложение с переносом и вычитание с заёмом} \label{addWithCarryInstruction}
Это команды add\_c, sub\_b. В них dest и src1 являются векторами из двух целых чисел, а src2 --- вектор из целых чисел, в котором используется только первый элемент.

add\_c: 
\begin{verbatim}
   sum = src1[0] + src2[0] + (src1[1] & 1)
   dest[0] = bit 0-63 of sum 
   dest[1] = bit 64 of sum
\end{verbatim}

sub\_b:
\begin{verbatim}
   sum = src1[0] - src2[0] - (src1[1] & 1)
   dest[0] = bit 0-63 of sum 
   dest[1] = bit 64 of sum
\end{verbatim}

Поддержка этих команд необязательна. Более длинные векторы --- не поддерживаются. См. с.~\pageref{highPrecisionArithmetic} по поводу иных вариантов для более длинных векторов.

\subsubsection{Арифметические команды с проверкой переполнения} \label{instructionsWithOverflowCheck}
Это команды add\_oc, sub\_oc, subr\_oc, mul\_oc, div\_oc.

Данные команды для арифметических вычислений используют элементы векторов, имеющие чётные номера. Каждый следующий элемент вектора, имеющий нечётный номер, используется для обнаружения переполнения. Если первый операнд--источник является скаляром, то результирующий операнд будет вектором из двух элементов.

Условия переполнения указываются следующими разрядами:

разряд №0. беззнаковое целочисленное переполнение(перенос)

разряд №1. знаковое целочисленное переполнение

разряд №2. вещественное переполнение

разряд №3. недопустимая вещественная операция

Значения распространяются так, чтобы к результат переполнения операции и обоим входным операндам применяется поразрядное ИЛИ.

Данные команды необязательны.

\subsubsection{Расширенное деление} \label{extendedDivisionInstruction}
Это команды div\_ex\_s, div\_ex\_u.

Они необязательны, и могут поддерживаться и для скаляров, и для векторов; только для скаляров; или не поддерживаться вовсе.

\subsubsection{byte\_reverse}
Данная команда обращает порядок байтов в целом числе. Она может использоваться при чтении и записи двоичных файлов данных с обратным порядком байтов.

\subsubsection{read\_spev}
Значение поля RT указывает специальный регистр, который нужно прочитать. Приёмник является векторным регистром, длина которого указана в RS.

На данный момент определены следующие специальные регистры:

\begin{longtable} {|p{20mm}|p{130mm}|}
\caption{Специальные регистры, которые можно прочесть в векторы} 
\label{table:specialVectorRegisters} \\
\endfirsthead
\endhead
\hline
\bfseries Номер специального регистра & \bfseries Смысл  \\ \hline
0                                     & Численный управляющий регистр (NUMCONTR). Это значение рассылается во все элементы регистра--приёмника с указанными размером операнда и длиной.  \\ \hline
1                                     & Имя процессора. Результат является заканчивающейся нулём строкой в кодировке UTF-8, содержащей торговую марку и имя модели микропроцессора. \\ \hline
\end{longtable}

\subsubsection{replace}
Все элементы из src1 заменяются целочисленной или вещественной константой из src2.

При использовании без маски константа просто рассылается, чтобы сделать вектор того же размера, что и src1. При использовании с маской элементы из src1 заменяются выборочно. В зависимости от разряда №1 маски, невыбранные элементы обнуляются или остаются без изменений.

\subsubsection{make\_mask}
%Make a mask from the bits of the 32-bit integer constant src2. Each bit of src2 goes into bit 0 of one element of the output. The remaining bits of each element are taken from src1. The length of the output is the same as the length of src1. If there are more than 32 elements in the vector then the bit pattern of src2 is repeated.
%
%
%\subsubsection{fp\_category}
%The input is a floating point vector. The output is a boolean vector indicating if the input belongs to any of the categories indicated by the bits in the immediate operand:
%
%\begin{longtable} {|p{20mm}|p{90mm}|}
%\caption{Meaning of bits in fp\_category} 
%\label{table:fpCategoryInstructionBits} \\
%\endfirsthead
%\endhead
%\hline
%\bfseries Bit number & \bfseries Meaning  \\
%\hline
%0 & Invert result \\
%1 & Zero \\
%2 & Subnormal  \\
%3 & Normal \\
%4 & Infinite  \\
%5 & NAN \\
%6 & Sign bit  \\
%7 & Copy remaining bits from mask or numeric control register.  \\
%\hline
%\end{longtable}
%  
%
%\subsubsection{Truth table functions} \label{truthTableFunctions}
%truth\_tab2, truth\_tab3, truth\_tab4
%\vspace{2mm}
%
%These instructions can make an arbitrary boolean function of two, three or four boolean vector input variables, expressed by a truth table. The result in bit 0 of each vector element is the arbitrary boolean function of bit 0 of the corresponding elements of each of the input operands. Bit 0 of the output is a bit from the truth table selected by the combined input bits. The remaining bits of the output vector are copied from the mask register if there is one, or from the first input operand otherwise. 
%\vspace{2mm}
%
%truth\_tab2 has the inputs in RD and RS, the output in RD, and a 4-bit truth table in IM1.
%\vspace{2mm}
%
%truth\_tab3 has the inputs in RS, RT and RU, the output in RD, and an 8-bit truth table in IM2.
%\vspace{2mm}
%
%truth\_tab4 has the inputs in RD, RS, RT and RU, the output in RD, and a 16-bit truth table in IM2.
%\vspace{2mm}
%
%truth\_tab4 must have an operand size of at least 16 bits. truth\_tab3 and truth\_tab4 are optional.
%\vspace{2mm}
%
%A mask can be used as an extra input operand for truth\_tab3 and truth\_tab4, according to the normal function of a mask.
%\vspace{2mm}
%
%These instructions can be used as universal instructions for manipulating and combining boolean vectors and masks.
%\vspace{2mm}
%
%The hardware implementation can use the existing barrel shifters, shifting the truth table right by the count defined by the combined bits of the input operands.
%
%
%\subsubsection{add\_add\_add} \label{addAddAdd}
%Adds four operands. The last operand can be a register operand or a 16-bit signed immediate operand. The signs of the operands can be inverted as indicated by bits 0-3 of the OP3 field:
%\vspace{2mm}
%
%bit 0: change sign of src1
%
%bit 1: change sign of src2
%
%bit 2: change sign of src3
%
%bit 3: change sign of src4
%\vspace{2mm}
%
%See add\_add page \pageref{addAdd} for more details.
%\vspace{2mm}
%
%This instruction is optional.
%
%
%\section{Common operations that have no dedicated instruction}
%This section discusses some common operations that are not implemented as single instructions, and how to code these operations in software.
%
%\subsubsection{Change sign}
%For integer operands, do a reverse subtract from zero. For floating point operands, use the toggle\_b instruction on the sign bit.
%
%\subsubsection{Floating point abs}
%To get the absolute value of a floating point number, use the clear\_b instruction to clear the sign bit.
%
%\subsubsection{Not}
%To invert all bits in an integer, do an XOR with -1. To invert a Boolean, do an XOR with 1.
%
%\subsubsection{Rotate through carry}
%Rotates through carry are rarely used, and common implementations can be very inefficient. A rotate left through carry can be replaced by an add\_c with the same register in both source operands.
%
%\subsubsection{Horizontal vector add} \label{horizontalVectorAdd}
%An instruction for adding all elements of a vector would be useful, but such an instruction is not supported because this would be a complex instruction with variable latency depending on the vector length.
%\vspace{2mm}
%
%The sum of all elements of a vector can be calculated by repeatedly adding the lower half and the upper half of the vector. This method is illustrated by the following example, finding the horizontal sum of a vector of 32-bit integers. The syntax for assembly language is described on page \pageref{assemblySyntax}.
%
%\begin{lstlisting}[frame=none]
%   v0 = my_vector   // we want the horizontal sum of this vector
%   r0 = get_len(v0) // length of vector in bytes
%   r0 = roundu2.64(r0)  // round up to nearest power of 2
%   v0 = set_len(v0, r0) // adjust vector length
%   // Loop to calculate horizontal sum of v0
%   LOOP: // label
%      // Half vector length
%      r1 = shift_rightu.64(r0, 1)
%      // Get upper half of vector
%      v1 = shift_reduce(v0, r1)
%      // Add upper half and lower half
%      v0 = add.32(v1, v0)  // result has the length of the first operand
%      // Half length for next iteration
%      r0 = r1
%      // loop while vector contains more than one element
%      compare_unsign_jmpabove(r1, 4, LOOP)      
%   // The sum is now a scalar in v0
%\end{lstlisting}
%
%The same method can be used for other horizontal operations. It may cause problems that the set\_len instruction inserts elements of zero if the vector length is not a power of 2. Special care is needed if the operation does not allow extra elements of zero, for example if the operation involves multiplication or finding the minimum element. A possible solution is to mask off the unused elements in the first iteration. The following example finds the smallest element in a vector of floating point numbers:
%
%\begin{lstlisting}[frame=none]
%   v0 = my_vector              // find the smallest element in this vector
%   r0 = get_len(v0)            // length of vector in bytes
%   r1 = roundu2.64(r0)         // round up to nearest power of 2
%   r1 = shift_rightu.64(r1, 1) // half length
%   v1 = shift_reduce(v0, r1)   // upper part of vector
%   r2 = sub.64(r0, r1)         // length of v1
%   // use mask because the two operands may have different length
%   v0 = set_len(v0, r1)        // reduce length of v0
%   v2 = v0                     // arbitrary vector with length r1
%   v2 = mask_length.32(v2, r2, 0x22)  // make mask for v1
%   v0 = min.f(v0, v1, mask=v2) // get minimum. mask off unused elements
%   cmp_unsign_jmpbeloweq(r1, 4, ENDOFLOOP) // check if already finished
%   // Loop to calculate horizontal minimum of v0
%   LOOP: // label
%      // Half vector length
%      r2 = shift_rightu.64(r1, 1)
%      // Get upper half of vector
%      v1 = shift_reduce(v0, r2)
%      // Get minimum of upper half and lower half
%      v0 = min.f(v1, v0)  // result has the length of the first operand
%      // Half length for next iteration
%      r1 = r2
%      // loop while vector contains more than one element
%      compare_unsign_jmpabove(r2, 4, LOOP)
%   ENDOFLOOP:      
%   // The minimum is now a scalar in v0
%\end{lstlisting}
%
%
%\subsubsection{High precision arithmetic} \label{highPrecisionArithmetic}
%Function libraries for high precision arithmetic typically use a long sequence of add-with-carry instructions for adding integers with a very large number of bits. A more efficient method for big number calculation is to use vector addition and a carry-look-ahead method. The following algorithm calculates A + B, where A and B are big integers represented as two vectors of n$\cdot$64 bits each, where n \textless{} 64.
%\vspace{2mm}
%
%\begin{lstlisting}[frame=none]
%v0 = A                   // first vector, n*64 bits
%v1 = B                   // second vector, n*64 bits
%v2 = carry_in            // scalar in vector register
%v0 = add.64(v0, v1)      // sum without intermediate carries
%v3 = compare.64(v0,v1,8) // carry generate = (SUM < B). (unsigned compare)
%v4 = compare.64(v0,-1,0xA) // carry propagate = (SUM == -1) 
%v3 = bool2bits(v3)       // carry generate, compressed to bitfield
%v4 = bool2bits(v4)       // carry propagate, compressed to bitfield
%// CA = CP ^ (CP + (CG<<1) + CIN) // propagated additional carry
%v3 = shift_left.64(v3,1) // shift left carry generate
%v2 = add.64(v2,v4)
%v2 = add.64(v2,v3)
%v2 = xor.64(v2,v4)
%v1 = bits2bool(v2)       // expand additional carry to vector
%v0 = sum.64(v0,v1)       // add correction to sum
%r0 = get_num(v0)         // n = number of elements in vectors
%v3 = gp2vec.64(r0)       // copy to vector register
%v2 = shift_rightu.64(v2,v3) // carry out
%// v0 = sum, v2 = carry out
%\end{lstlisting}
%\vspace{2mm}
%
%If the numbers A and B are longer than the maximum vector length then the algorithm is repeated. If the vector length is more than 64 * 8 bytes then the calculation of the additional carry involves more than 64 bits, which again requires a big number algorithm.
%
%
%\section{Unused instructions} \label{unusedInstructions}
%Unused instructions and opcodes can be divided into three types:
%
%\begin{enumerate}
%\item The opcode is reserved for future use. Attempts to execute it will trigger a trap (synchronous interrupt) which can be used for generating an error message or for emulating instructions that are not supported.
%\item The opcode is guaranteed to generate a trap, not only in the present version, but also in all future versions. This can be used as a filler in unused parts of the memory or for indicating unrecoverable errors. It can also be used for emulating user-specific instructions.
%\item The error is ignored and does not trigger a trap. It can be used for future extensions that improve performance or functionality, but which can be safely ignored when not supported.
%\end{enumerate}
%
%All three types are implemented, where type 1 is the most common.
%\vspace{2mm}
%
%Nop instructions with nonzero values in unused fields are type 3. These instructions are ignored.
%\vspace{2mm}
%
%Prefetch and fence instructions with no memory operand, with nonzero values in unused fields, or with undefined values in OP3 are type 3. These instructions are ignored.
%\vspace{2mm}
%
%Unused bits in masks and numeric control register are type 3. These bits are ignored.
%\vspace{2mm}
%
%Trap instructions and conditional trap instructions with nonzero values in unused fields or undefined values in any field are type 2. These instructions are guaranteed to generate a trap. A special version of the trap instruction is intended as filler in unused or inaccessible parts of code memory.
%\vspace{2mm}
%
%The undef instruction is type 2. It is guaranteed to generate a trap in all systems. It can be used for testing purposes and emulation.
%\vspace{2mm}
%
%The userdef\_\_ instructions are type 1. These instructions are reserved for user-defined and application-specific purposes.
%\vspace{2mm}
%
%Instructions with erroneous coding should preferably behave as type 1. This includes instruction codes with nonzero values in unused fields, operand types not supported, or any other bit pattern with no defined meaning in any field. Type 3 behavior may alternatively be allowed in these cases. If so, the instruction should behave as if it were coded correctly.
%\vspace{2mm}
%
%All other opcodes not explicitly defined are type 1. These may be used for future instructions.
%\vspace{2mm}
%
%Small systems with no operating system and no trap support should define alternative behavior. 
\end{document}