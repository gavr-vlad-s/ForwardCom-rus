% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\section{Синтаксис языка ассемблера} \label{assemblySyntax}
В определение нового набора команд следует включать определение стандартизированного синтаксиса языка ассемблера. Синтаксису следует быть подходящим для обработки человеком, а не только машиной. Мнемоническим именам следует быть достаточно длинными, чтобы иметь смысл. Командам следует иметь операнд--приёмник в качестве первого операнда. Мы обязательно должны избегать ситуаций, схожих с x86, когда используется много разных синтаксисов, с разными именами команд и разным порядком операндов.

Ассемблерный код имеет в каждой строке одну команду, состоящую из мнемоники команды и её операндов. Предлагается, для указания типа операндов, приписывать к именам команд суффикс, отделённый от имени точкой:  8, 16, 32, 64, 128 для размера целочисленных операндов, и f, d, q для вещественных операндов одинарной, двойной, и четырёхкратной точности. Добавляйте к типу целочисленного операнда 'z', если результат обязательно должен расширяться нулём до 64--разрядного регистра общего назначения. Без 'z' ассемблер подберёт самую короткую команду, независимо от того, может ли произойти переполнение результата в дополнительных разрядах. Например, add.16 r0,r0,1 может использовать малую команду с 64--разрядным типом операнда, и в которой может за пределами 16 разрядов произойти переполнение, тогда как add.16z r0,r0,1 обязательно должна использовать команду с 16--разрядным типом операнда, гарантируя, что оставшиеся разряды регистра общего назначения будут нулями.

Находящийся в памяти операнд указывается в квадратных скобках. Значение длины вектора для находящегося в памяти операнда указывается как \glqq, length=регистр\grqq, после адреса операнда. Регистр маски указывается как \glqq, mask=регистр\grqq. Пример:
\begin{verbatim}
   add.f v0, v1, [r2+0x100, length=r3], mask=v4
\end{verbatim}
Здесь будет сложены вещественный вектор v1 и находящийся в памяти вектор, имеющий указатель r2, смещение 0x100, и длину (в байтах) в r3, а результат будет сохранён в v0, используя маску v4. 

Операнд--массив указывается как
$$
\texttt{(базовый регистр)+(индексный регистр)*(масштабирующий множитель)}.
$$
Если имеется $\text{(масштабирующий множитель)}\neq\pm1$, то масштабирующий множитель обязательно должен совпадать с размером операнда, указанным суффиксом типа операнда. Лимит на индекс указывается в виде \glqq, limit=значение\grqq. Пример:
\begin{verbatim}
   add.64 r0, r1, [r2+r3*8, limit=999], mask=r4
\end{verbatim}
Здесь из массива в 1000 элементов, с базовым адресом r2 и индексом r3, который масштабируется на размер операнда (64 разряда = 8 байт), с лимитом индекса r3 $\leq$ 999, загружается 64--разрядное целое, складывается со значением в r1, а результат сохраняется в r0, используя маску из r4.

Ту же команду можно записать иначе, в стиле функции: 
\begin{verbatim}
   r0 = add.64 (r1, [r2+r3*8, limit=999], mask=r4)
\end{verbatim}

Команды пересылки могут быть удобно записаны просто через знак равенства, например
\begin{verbatim}
   r0 = r1              ; копировать регистр общего назначения
   r2 = 0xFFFF          ; установить регистр общего назначения равным константе
   v3 = [r4, length=r5] ; прочесть находящийся в памяти операнд в векторный регистр
\end{verbatim}

Комментарии указываются через точку с запятой или двойной слэш.

У традиционных ассемблеров часто имеются возможности для метапрограммирования, такие, как макросы, условные операторы препроцессора, и циклы препроцессора. Синтаксисы, используемые для этих возможностей, выглядят подобно несуразным специально придуманным решениям, без общей логической структуры. Мы бы предпочли синтаксис, делающий ясным различие между метапрограммированием и обычным ассемблерным кодом. В синтаксисе метапрограммирования следует поддерживать целочисленные и вещественные переменные, строки, макросы, условные операторы, и циклы, способом, напоминающим язык структурированного программирования.
\end{document}