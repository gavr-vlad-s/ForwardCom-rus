% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Модель памяти} \label{memoryModel}
Адресное пространство использует беззнаковые 64--разрядные адреса и 64--разрядные указатели. В будущем возможно расширение до 128--разрядных адресов, но это вряд ли будет уместно в обозримом будущем.

Абсолютные адреса используются редко. Большинство объектов данных, функций, и целей перехода адресуется с помощью смещения (разрядности, не большей 32) относительно некоторой точки отсчёта, содержащейся в 64--разрядном указателе. Этот указатель может быть указателем команд (IP), указателем секции данных (DATAP), указателем стека (SP), или регистром общего назначения.

Приложение может обращаться к следующим разделам данных.
\begin{itemize}
	\item Код программы (CODE). Этот блок является исполняемым, с возможностью чтения, или без неё, но без возможности записи. Секция CODE может разделяться между разными процессами, выполняющими одну и ту же программу.
	\item Константные данные программы (CONST). Она содержит константы и таблицы, используемые программой, без возможности записи. Может разделяться между несколькими процессами.
	\item Статические разделы данных, доступные и для чтения, и для записи, которые могут содержать как инициализированные данные (DATA), так и неинициализированные (BSS). Эти разделы используются для глобальных данных и для статических данных, определённых внутри функций. Необходимо несколько экземпляров, если несколько процессов выполняет один и тот же код. 
	\item Стековые данные (STACK). Данные раздел используется для нестатических данных, определённых внутри функций. Каждый процесс или поток имеет свой собственный стек, адресуемый относительно указателя стека. При добавлении данных в стек, тот растёт вниз, от старших адресов --- к младшим.
	\item Куча программы (HEAP). Используется для динамического выделения памяти прикладной программой.
	\item Данные потока (THREADD). Выделяются, когда поток создаётся, и используются для локальных статических данных потока и для блока окружения потока.
\end{itemize}

Ссылки в пределах секции CODE используют 8--разрядные, 24--разрядные, и 32--разрядные знаковые ссылки относительно указателя команд, умножаемого на размер слова кода, равный 4 байтам. 

Секцию CONST лучше помещать сразу после секции CODE. Данные в секции CONST в основном адресуются относительно указателя команд, без масштабирования\footnote{В случае чистой гарвардской архитектуры, секция CONST может быть помещена в доступную для чтения память программ, чтобы адресовать относительно указателя команд, или может быть помещена в память данных, и адресоваться относительно DATAP}. 

Секции DATA и BSS адресуются относительно указателя секции данных (DATAP), который является специальным регистром, указывающим на некоторую точку отсчёта, расположенную в этих разделах. Предпочтительной точкой отсчёта является место, где DATA заканчивается, а BSS --- начинается. Несколько выполняющихся экземпляров одной и той же программы будут иметь разные значения указателя секции данных. Секции  CODE и CONST содержат не прямые ссылки на  DATA или BSS, а лишь смещения относительно указателя секции данных, что делаем возможным нескольким процессам разделять одни и те же секции CODE и CONST, но иметь собственные закрытые секции DATA и BSS, без необходимости в трансляции виртуальных адресов. Секции DATA и BSS могут размещаться где угодно в адресном пространстве, независимо от того, где размещаются CONST и CODE.

Данные в секции STACK адресуются относительно указателя стека (SP). Данные, находящиеся в куче, адресуются через указатели, предоставленные функцией выделения памяти в куче.

Данные потока адресуются относительно регистра, называемого указателем блока окружения потока, который свой у каждого потока процесса. Блок окружения потока может выделяться в стеке, когда создаётся новый поток.

Секции данных STACK, DATA, BSS, HEAP и THREADD лучше хранить совместно, в непрерывном блоке, чтобы  оптимизировать кэширование и управление памятью. 

Данная модель позволяет программе обращаться к секции CODE размером вплоть до 8Гб, секции CONST --- до 2Гб, секции DATA --- до 2Гб, секции BSS --- до 2Гб, секции THREADD --- до 2Гб, секции STACK почти неограниченного размера, с кадрами по 2Гб, и почти неограниченному количеству данных в секции HEAP. Чтобы обращаться к данным из CONST в том редком случае, когда расстояние между кодом и данными превышает 2Гб, либо чтобы избежать перемещения адресов, в блоке окружения потока предоставляется указатель на секцию CONST. 

Конец объединённого блока данных, находящихся в памяти, должен иметь неиспользуемое пространство того же размера, что и максимальная длина вектора. Это позволит команде restore\_cp читать больше, чем необходимо, при восстановлении вектора неизвестной длины;  а также позволит функции, находящей конец заканчивающейся нулём строки, читать по одному куску размером с длину вектора за раз, не вызывая нарушений доступа из--за чтения в недоступной части памяти.

У большинства микропроцессорных систем стек растёт вниз. У системы ForwardCom дело обстоит так же, но, в основном, по другой причине. Когда в стеке сохраняется векторный регистр, он сохраняется так: сначала идёт длина, а потом --- количество данных, указанное длиной. Когда векторный регистр восстанавливается (с использованием команды restore\_cp), необходимо прочесть  длину, за которой идут данные. Указатель стека должен указывать на младший адрес, где хранится длина, иначе было бы невозможно найти, где длина хранится.

\section{Защита памяти потока} \label{threadMemoryProtection}
У каждого потока обязательно должен быть свой собственный стек. Данные потока (THREADD) могут быть размещены в этом стеке. Система ForwardCom позволяет межпоточную защиту памяти. Стековые данные основного потока программы доступны всем её дочерним потокам, но все прочие потоки программы могут иметь закрытые данные, недоступные никаким другим потокам, даже основному. Любая коммуникация между потоками или синхронизация таковых обязательно должна использовать статическую память или память, принадлежащую основному потоку.

Рекомендуется использовать эту межпоточную защиту памяти во всех случаях, исключая устаревшее программное обеспечение, требующее единого пространства памяти, разделяемого всеми потоками.

\subsubsection{Изолированные блоки памяти} \label{isolatedMemoryBlocks}
Возможно создание системной функции, выделяющей изолированный блок памяти, с обеих сторон окружённого недоступной памятью. Такой блок памяти, который будет недоступен только конкретному потоку, может использоваться, например, для входного буфера, в случае высоких требований к безопасности. Каждый поток может иметь лишь ограниченное количество таких защищённых блоков памяти, из--за ограниченного размера карты памяти.

\section{Управление памятью} \label{memoryManagement}
Цель дизайна --- минимизировать фрагментацию памяти и необходимость в трансляции виртуальных адресов. В имеющихся дизайнах часто имеются очень сложные системы управления памятью, с многоуровневой трансляцией адресов, больш\'{и}м буфером ассоциативной трансляции (translation-lookaside-buffers, TLB), и огромными таблицами страниц. Мы хотим заменить TLB, имеющий большое количество блоков памяти фиксированного размера, картой памяти, имеющей небольшое количество блоков памяти переменного размера. В большинстве случаев основному потоку приложения будет необходимо лишь три блока памяти CONST (только для чтения), CODE (только для выполнения), и объединённые STACK+DATA+BSS+HEAP (для чтения и записи). Дочернему потоку нужен ещё один блок, для своего закрытого стека. Аналогичные блоки определяются для системного кода.

Карту памяти с таким ограниченным количеством элементов можно  легко реализовать на кристалле, очень эффективным способом, и можно легко изменять при переключении задач. Каждый процесс и каждый поток обязан иметь свою собственную карту памяти. Эта память не разбивается на страницы фиксированного размера. 

Карта памяти поддерживает трансляцию виртуальных адресов, в виде константного смещения, для каждого элемента карты определяющего расстояние между виртуальным адресом и физическим. Аппаратуре не следует тратить время и энергию на трансляцию виртуальных адресов, когда она не используется.

В карте памяти предоставляется ограниченное количество дополнительных элементов, чтобы обработать случаи, когда память становится фрагментированной. Однако в большинстве случаев фрагментации памяти можно избежать. Для упрощения управления памятью и устранения фрагментации памяти предоставляются следующие приёмы:
\begin{itemize}
\item Есть только один тип библиотек функций, который можно использовать и для статической компоновки, и для динамической. Они компонуются с помощью механизма, в большинстве случаев сохраняющего непрерывность расположения секций CONST, CODE и DATA с аналогичными секциями основной программы. Данный приём описан ниже, на с.~\pageref{libraryLinkMethods}.

\item Требуемый размер стека вычисляется компилятором и компоновщиком, так что в большинстве случаев переполнения стека можно избежать. Данный приём описан на с.~\pageref{predictingStackSize}.

\item Операционная система может сохранять статистические записи о размере кучи каждой программы, чтобы предсказать требуемый размер кучи. Тот же самый приём можно использовать для предсказания размера стека, когда размер стека нельзя предсказать точно (например, при рекурсивных вызовах функций). 
\end{itemize}

Несмотря на использование этих приёмов, пространство памяти может стать фрагментированным. Проблемы, который могут стать результатом фрагментации памяти, перечислены ниже.
\begin{itemize}
\item Рекурсивные функции могут использовать неограниченное пространство стека. Мы можем потребовать, чтобы программист указывал прагмой максимальный уровень рекурсии.

\item Выделение в стеке памяти для массивов переменного размера с помощью C--функции alloca. Мы можем потребовать, чтобы программист указывал максимальный размер.

\item Компоновка времени выполнения. Программа может резервировать место для загрузки и компоновки библиотек функций во время выполнения (см. с.~\pageref{runtimeLinking}). Память может стать фрагментированной, если памяти, зарезервированной для этой цели, оказалось недостаточно.

\item Языки сценариев и языки, использующие байт--код.  Сложно предсказать требуемый размер стека и кучи при выполнении интерпретируемого или эмулируемого кода. Рекомендуется вместо этого использовать компиляцию \glqq на лету\grqq. Самомодифицирующиеся сценарии компилироваться не могут. Та же проблема может возникнуть с большими определяемыми пользователем макросами.

\item Непредсказуемое количество потоков без защиты. Требуемый размер стека для потока может быть вычислен заранее, но в некоторых случаях предсказание количества потоков, которые программа породит, может оказаться сложным. Много потоков будет, в основном, разделять одну и ту же секцию кода, но им нужны отдельные стеки. Стек потока, если используется межпоточная защита памяти, без проблем может располагаться где угодно в памяти.
Однако, если память разделяется между потоками, и количество потоков --- непредсказуемо, то область разделяемой памяти может стать фрагментированной.

\item Непредсказуемый размер кучи. Программам, обрабатывающим большие объёмы данных, например, обрабатывающие мультимедиа, может потребоваться большая куча. Куча может использовать не смежные области памяти, но это потребует дополнительных элементов в карте памяти.

\item Ленивая загрузка и перекрытия кода. Большая программа может иметь некоторые модули кода, которые редко используются, и загружаются только по необходимости. Ленивая загрузка может быть полезной для экономии памяти, но она может потребовать трансляции виртуальной памяти, и может вызвать фрагментацию памяти. Прямолинейное решение состоит в реализации таких модулей кода в виде отдельных исполняемых программ. 

\item Горячее обновление, т.е. обновление кода во время его работы. 

\item Разделяемая память для связи между процессами. Это, как объяснено ниже, требует дополнительных элементов в карте памяти.

\item Выполнение многих программ. Память может стать фрагментированной, когда случайно загружается и выгружается, или сбрасывается в память, много программ разных размеров,
\end{itemize}

Возможным средством от переполнения стека и кучи является размещение STACK, DATA, BSS и HEAP совместно (в этом порядке), в адресном диапазоне с большими неиспользуемыми адресными пространствами ниже и выше, так что стек может расти вниз (в сторону младших адресов), а куча --- вверх, в свободное место. Данный метод может устранить фрагментацию виртуального адресного пространства, но не физического. Фрагментацию физического адресного пространства можно вылечить перемещением данных из блока памяти недостаточного размера в другой блок, большего размера. У этого метода есть цена --- задержка во времени при перемещении данных. 

Если компоновка во время выполнения работает в памяти, и отсутствуют элементов карты памяти, то допускается смешивать секции CONST и CODE в одну общую секцию, с доступом и по чтению, и на выполнение. Если библиотека функций содержит константные данные, исходящие из недоверенного источника, тогда как код --- доверен, то предпочтительнее поместить недоверенные данные в секцию DATA, а не CONST, чтобы предотвратить выполнение зловредного кода, помещённого в секции CONST.

\label{sharedMemory}
Разделяемая память может использоваться, когда имеется необходимость передачи больших объёмов данных между двумя процессами. Один процесс разделяет часть своей памяти с другим процессом. Процессу--получателю нужен дополнительный элемент в своей карте памяти, с тем, чтобы для разделяемого блока памяти указать права на чтение и/или запись.Процессу, владеющему блоком разделяемой памяти, не нужно никаких дополнительных элементов в его карте памяти. Имеется ограничение на то, к скольким блокам разделяемой памяти приложение может получить доступ, ибо мы хотим сохранить карту памяти малой. Если одной программе нужно общаться с большим количеством других программ, то мы можем использовать одно из следующих решений: (1) позволить программе, которой нужно много связей, владеть разделяемой памятью, и дать каждому из её клиентов доступ к одной из частей этой памяти; (2) выполнять в программе, которой нужно много связей, много потоков, или выполнять много экземпляров такой программы, так, чтобы каждый поток имел доступ только к одному разделяемому блоку памяти; (3) позволить много каналов коммуникации, использующих один и тот же блок разделяемой памяти, или части его;  (4) общаться через вызовы функций; (5) общаться через сетевые сокеты; или (6) общаться через файлы. 

Исполняемая память не может разделяться между разными приложениями. Если одному приложению нужно вызвать функцию другого приложения, обязательно нужно использовать механизм межпроцессных вызовов, описанный на с.~\pageref{interProcessCalls}. 

Используя обсуждённые здесь принципы, мы можем, вероятно, сохранить фрагментацию памяти столь малой, что для охвата нормальных случаев для каждого потока будет достаточно малой карты памяти, что будет намного эффективнее, нежели большой TLB и многоуровневая трансляция адресов имеющихся дизайнов. Это сэкономит объём кремния и энергию, и мы можем избежать платы за промахи TLB и отсутствие страниц, что сделает переключение задач очень быстрым.
\end{document}