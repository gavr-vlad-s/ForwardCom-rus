% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\section{Двоичный формат для объектных файлов и исполняемых файлов} \label{objectFileFormat}
Формат исполняемого файла должен быть стандартизирован. Из широко распространённых форматов, наиболее гибким и хорошо структурированным, является, вероятно, формат ELF. Для объектных файлов, библиотек функций, и исполняемых файлов предлагается использовать формат ELF. 

Детали формата ELF для ForwardCom указаны в файле с именем elf\_forwardcom.h. Эта спецификация включает детали типов секций, типы переразмещений, и т.п. В формат файла добавлены дополнительные сведения, об использовании регистров (см. с.~\pageref{registerUsageConvention}) и использовании стека (см. с.~\pageref{predictingStackSize}). 

Имена файлов обязательно должны иметь расширения, указывающие их тип. Предполагается использовать следующие расширения: ассемблерный код ---  .as, объектный файл ---  .ob, библиотечный файл ---  .li, исполняемый файл --- .ex. 

\section{Библиотеки функций и методы компоновки} \label{libraryLinkMethods}
Динамически компонуемые библиотеки (DLL) и разделяемые объекты (SO) в системе ForwardCom не используются. Вместо этого мы будем использовать только один тип библиотек функций, который можно использовать тремя разными способами.
\begin{enumerate}
\item Статическая компоновка. \label{staticLinking} Компоновщик находит в библиотеке требуемые функции и копирует их в исполняемый файл. Включаются лишь те части библиотеки, которые действительно нужны конкретной головной программе. Этот способ в нынешних системах обычно используется для статических библиотек (.lib--файлы в Windows, .a--файлы в Uni--подобных системах, таких, как Linux, BSD, и Mac OS).

\item Компоновка во время загрузки. \label{loadTimeLinking} Библиотека может распространяться отдельно от исполняемого файла. Требуемые части библиотеки загружаются в память совместно с исполняемым файлом, и все ссылки между головным исполняемым файлом и библиотечными функциями разрешаются загрузчиком тем же способом, что и при статической компоновке.

\item Компоновка во время выполнения. \label{runtimeLinking} Выполняющаяся программа вызывает системную функцию, возвращающую указатель на библиотечную функцию. Требуемая функция выделяется из библиотеки и загружается в память, предпочтительно в область памяти, зарезервированную для этой цели головной программой. Любые ссылки вновь загруженной функции на другие функции, загруженные ли уже или нет, могут быть разрешены тем же способом, что и при статической компоновке.
\end{enumerate}

Данные методы улучшат производительность и избавят от многих проблем, с которыми мы сталкивались для традиционных DLL и SO. Типичной программе в Windows и в Unix--системах при загрузке требуется несколько  DLL или SO. Все эти динамические библиотеки  будут загружены, каждая в свой блок памяти, каждый из которых использует целое число страниц, и, возможно, они разбросаны по памяти, что приводит к пустой трате памяти и плохому кэшированию. Ещё одной проблемой с производительностью при использовании разделяемых объектов является то, что они используют таблицу компоновки процедур (procedure linkage tables, PLT) и глобальную таблицу смещений (GOT) для всех обращений к функциям и переменным, чтобы поддерживать редко используемую возможность внедрения символов. Это требует просмотра  PLT или GOT при каждом обращении в библиотеке к функции или переменной, включая внутренние ссылки на глобально видимые символы.

Система ForwardCom заменяет традиционные динамическую компоновку приведённым выше методом 2, который сделает код столь же эффективным, что и при статической компоновке, поскольку секции библиотек располагаются подряд с секциями головной программы, и все обращения являются непосредственными, без промежуточных таблиц. Время, требуемое для загрузки библиотеки, будет схоже с временем, требуемым для динамической компоновки, поскольку узким местом будет обращение к диску, а не вычисление адресов функций.

DLL или SO могут разделять свою секцию кода (но не свою секцию данных) между многими выполняющимися программами, использующими одну и ту же библиотеку. Библиотека в ForwardCom может разделять свою секцию кода между многими экземплярами одной и той же программы, но не между разными программами. Количество памяти, потраченное на возможную загрузку многих экземпляров одного и того же библиотечного кода более чем компенсируется тем, что мы загружаем лишь ту часть библиотеки, которая действительно необходима, и что библиотеке не требуются свои собственные страницы памяти. В Windows и в Unix--системах необычно обычно не загружают динамическую библиотеку размером в один мегабайт, чтобы использовать из неё лишь один килобайт.

Компоновка во время выполнения (метод №2 из приведённых выше) в системе ForwardCom --- эффективна, из--за способа использования относительных адресов. Головная программа обычно содержит секцию CONST, непосредственно идущую после секции CODE. Секция CONST адресуется относительно указателя команд, так что эти две секции в памяти можно разместить вместе, до тех пор, пока они имеют одно и то же расположение друг относительно друга. Теперь мы можем поместить секцию CONST библиотечной функции перед секцией CONST головной программы, а секцию CODE библиотечной функции --- после секции CODE головной программы. Мы не должны изменять в головной программе какие--либо перекрёстные ссылки. Загрузчиком должны быть вычислены и вставлены в код только перекрёстные ссылки между головной программой и библиотечной функцией и между секциями CODE и CONST библиотечной функции.

Библиотечной функции не нужно иметь никаких секций DATA и BSS. В действительности, потокобезопасная функция мало использует статические данные. Однако если у библиотечной функции есть какие--либо секции DATA и BSS, то эти секции можно разместить где угодно, в пределах диапазона $\pm$2Гб от указателя DATAP. Ссылки в библиотечной функции на её статические данные должны вычисляться относительно точки, на которую указывает DATAP; а ссылки  на данные в головной программе --- не должны модифицироваться, до тех пор, пока DATAP всё ещё указывает в границах секций  DATA и BSS головной программы. 

Головная программа, объединённая с файлом библиотеки, теперь может быть загружена в любое свободное место памяти. В карте памяти потребуется лишь три  элемента: (1) объединённые секции CONST библиотеки и головной программы, (2) объединённые секции CODE головной программы и библиотечных функций, и (3) объединённые секции STACK, DATA, BSS, и HEAP головной программы и библиотечных функций.

Компоновка во время выполнения работает несколько иначе. Ссылка из головной программы на библиотечную функцию идёт через указатель на функцию, предоставляемый при загрузке библиотеки. Любые ссылки в ином направлении --- из библиотечных функций на функции или глобальные данные головной программы --- могут разрешаться тем же способом, что и для методов №№1 и 2, или через указатели, являющиеся параметрами функции. Головной программе желательно зарезервировать место для секций CONST, CODE и DATA/BSS любых библиотек, которые будут загружены во время выполнения. Размеры этих зарезервированных пространств предоставляются в заголовке исполняемого файла. У загрузчика есть значительная свобода в размещении этих секций где он может, если зарезервированных областей недостаточно. Единственное требование состоит в том, чтобы секция CONST библиотечной функции размещалась в диапазоне $\pm$2Гб от секции кода библиотеки, а секции DATA и BSS библиотеки находились в пределах $\pm$2Гб от DATAP. Библиотечная функция может быть откомпилирована с опцией компилятора, говорящей не использовать DATAP. Функция будет загружать абсолютный адрес своей секции DATA в регистр общего назначения, и обращаться к своим данным, используя этот регистр в качестве указателя.

\section{Система диспетчеризации библиотечных функций} \label{libraryFunctionDispatchSystem}
У более новых версий Linux имеется возможность, называемая косвенной функцией Gnu, делающая возможным выбор разных версий функции в момент загрузки, в зависимости, например, от версии микропроцессора. Эта возможность в систему ForwardCom скопирована не будет, ибо она основана на таблице компоновки процедур (procedure linkage tables, PLT). Вместо этого мы можем сделать систему--диспетчер, используемую с компоновкой во время загрузки. Библиотека может содержать функцию--диспетчер, говорящую, какую версию библиотечной функции загружать. Загрузчик вначале загрузит функцию--диспетчер и вызовет её. Функция--диспетчер возвращает имя выбранной версии желаемой функции. Затем загрузчик выгружает функцию--диспетчер, и компонует выбранную функцию с головной программой. Функция--диспетчер обязательно должна иметь доступ к сведениям об аппаратной конфигурации, параметрах командной строки, переменных окружения, операционной системе, каркасе пользовательского интерфейса, и всему прочему, что могло бы быть необходимым для выбора используемой версии функции.

\section{Предсказание размера стека} \label{predictingStackSize}
В большинстве случаев можно точно вычислить, какой объём стека потребуется приложению. Компилятор знает, какой объём стека выделялся в каждой функции. Мы лишь должны заставить компилятор сохранить эту информацию, чего можно достичь следующим способом. Если функция A вызывает функцию B, то мы хотим, чтобы компилятор сохранял сведения о разности между значением указателя стека, когда вызвана A, и значением указателя стека, когда вызвана B. Эти значения могут использоваться. Если функция компилируется отдельно, в своём собственном объектном файле, то сведения обязательно должны сохраняться в объектном файле.

Функция может использовать любое количество памяти ниже адреса, указанного указателем стека (так называемая \glqq красная зона\grqq), если она включена в размер стека, сообщённый в объектном файле, при условии, что у системы есть отдельный системный стек.

Объём памяти под стек, используемый функцией, будет зависеть от максимальной длины вектора, если в стеке сохраняются полные векторные регистры. Все значения требуемого объёма стека являются линейными функциями от длины вектора:
$$
\text{размер_кадра_стека}=\text{константа} + \text{множитель}\cdot\text{максимальная_длина_вектора}.
$$
Таким образом, для каждой функции и ветви имеется двя сохраняемых значения: $\text{константа}$ и $\text{множитель}$. Нам нужны отдельные вычисления для каждого потока, и, возможно, также сведения о количестве потоков. Если имеется два стека, то нам нужно сохранять отдельные значения для стека вызовов и для стека данных. Размер стека вызовов не зависит от максимальной длины вектора.

Компоновщик суммирует все эти сведения, и сохранит сохранит результат в заголовке исполняемого файла. Максимальная длина вектора известна при загрузке программы, так что загрузчик может завершить вычисления, и выделить стек вычисленного размера перед загрузкой программы. Это предотвратит переполнение стека и фрагментацию памяти для стека. Некоторые программы для оптимальной производительности будут использовать столько же потоков, сколько ядер у ЦП. Однако это несущественно для того, чтобы узнать, сколько потоков будет создано, поскольку каждый стек может размещаться в памяти где угодно, если используется защита памяти потока (см. с.~\pageref{threadMemoryProtection}). 

Теоретически, можно избежать необходимости в трансляции виртуальных адресов, если выполнены следующие четыре условия: 
\begin{itemize}
\item требуемый размер стека можно предсказать, и при загрузке программы и создании дополнительных потоков выделен достаточный объём стека;

\item статические переменные адресуются относительно указателя секции данных, работающие множественные экземпляры одной и той же программы имеют разные значения в указателе секции данных;

\item в случае переполнения кучи менеджер кучи может обрабатывать фрагментированную физическую память;

\item имеется достаточно памяти, так что приложению нет нужды пользоваться подкачкой с жёсткого диска.
\end{itemize}

Иной возможный вариант, нежели вычисление размера стека, состоит в измерении действительного размера стека, используемого при первом выполнении программы, и затем положиться на статистику для предсказания использования стека при последующих запусках. Тот же метод можно использовать для размера кучи. Данный метод проще, но менее надёжен. Вычисление требований к стеку с помощью компилятора наверняка охватывает все ветки программы, тогда как статистический метод включит только ветки, действительно выполнявшиеся.

Мы можем реализовать аппаратный регистр, измеряющий размер стека. Этот измеряющий размер стека регистр обновляется при каждом увеличении стека. Мы можем сбросить измеряющий объём стека регистр при запуске программы, и прочесть его при завершении программы. Нам не нужен аппаратный регистр для измерения размера кучи: эти сведения можно получить от менеджера кучи.

Эти предложения во многих случаях могут исключить или уменьшить фрагментацию памяти, так что нам потребуется лишь небольшая карта памяти, которую можно сохранить на кристалле ЦП. Каждый процесс и каждый поток будет иметь свою собственную карту памяти. Однако мы не можем полностью исключить фрагментацию памяти и необходимость в трансляции виртуальной памяти, из--за сложностей, обсуждённых на с.~\pageref{memoryManagement}.

\section{Обработка исключений, раскрутка стека, и отладочная информация} \label{exceptionHandling}
Исполняемые файлы обязательно должны содержать сведения о кадре стека каждой функции, ради обработки исключений и разворачивания стека для языков программирования, поддерживающих структурную обработку исключений. Их следует также использовать для языков программирования, не поддерживающих структурную обработку исключений, чтобы помочь в отслеживании стека отладчиком.

Данную систему следует стандартизировать, и следует поддерживать и для одностековых, и для двухстековых систем.  Рекомендуется использовать табличный метод, не требующий указателя кадра стека.

Отладчику нужны сведения о номерах строк, именах переменных, и т.п. Эти сведения следует включать в объектные файлы по запросу. Отладочная информация может быть скопирована в исполняемый файл или сохранена в отдельном файле, хранимом совместно с исполняемым файлом. Какую систему использовать --- ещё не решено. 
\end{document}