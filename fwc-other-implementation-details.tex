% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Другие детали реализации}
\section{Порядок байтов} \label{endianness}
Организация памяти использует прямой порядок байтов (от младшего к старшему). Для чтения и записи файлов данных с обратным порядком байтов предоставляются команды смены порядка байтов.

\subsubsection{Обоснование}
Если бы использовалась организация с обратным порядком байтов, то способ хранения вектора в памяти зависел бы от размер элемента. Например, предположим, что у нас есть 128--разрядный векторный регистр, содержащий четыре 32--разрядных целых числа, обозначенные A, B, C, D. При использовании прямого порядка байтов, они хранились бы в памяти в следующем порядке:

%A0, A1, A2, A3, B0, B1, B2, B3, C0, C1, C2, C3, D0, D1, D2, D3,

\noindent 
где A0 --- самый младший байт числа A, а D3 --- самый старший байт числа D. При использовании же обратного порядка мы бы имели

A3, A2, A1, A0, B3, B2, B1, B0, C3, C2, C1, C0, D3, D2, D1, D0.

Этот порядок изменился бы, если бы тот же самый векторный регистр был организован, например, как восемь целых чисел, по 16 разрядов в каждом, или как два целых числа, по 64 разряда в каждом. Иными словами, нам бы потребовались разные команды чтения и записи для разных способов организации вектора.

Прямой порядок байтов более распространён по большому количеству причин, многократно обсуждавшихся в иных местах.

\section{Реализация стека вызовов} \label{callStackAlternatives}
Есть разные методы сохранения адресов возврата при вызовах функций: регистр связи, отдельный стек вызовов, или унифицированный стек, и для адресов возврата, и для локальных данных. Здесь мы обсудим достоинства и недостатки каждого из этих методов.

\subsubsection{Регистр связи}
Некоторые системы для хранения адреса возврата используют регистр связи. Преимущество регистра связи состоит в том, что листовые функции могут вызываться без сохранения чего--либо в стеке, что экономит пропускную способность кэша в программах с большим количеством вызовов листовых функций. Недостаток состоит в том, что каждой нелистовой функции нужно перед вызовом другой функции сохранять регистр связи в стеке, и восстанавливать  его перед возвратом.

Если бы мы приняли решение использовать регистр связи, то им должен был бы быть специальный регистр, а не один из регистров общего назначения. Регистру связи не нужно поддерживать все вещи, которые можно делать с регистром общего назначения. Если регистр связи включается как один из регистров общего назначения, то у программиста возникнет соблазн сохранить регистр связи в другом регистре, а не в стеке, и затем, в конце функции, перейти по адресу, хранящемуся в том другом регистре. Это, конечно, работать будет, но помешает способам, которыми предсказываются возвраты. Модуль предсказания ветвления использует специальный механизм для предсказания возвратов, отличающийся от механизма, используемого для предсказания иных переходов и ветвлений. Данный механизм, называемый буфером стека возврата, представляет собой небольшой кольцевой кэш, запоминающий адреса последних вызовов. Если функция выполняет возврат переходом по адресу, содержащемуся в регистре, отличном от регистра связи, то она будет использовать ошибочный механизм предсказания, что вызовет большие задержки из--за неверного предсказания последующей серии возвратов. Буфер стека возврата также будет перепутан, если регистр связи используется для косвенного перехода или в иных целях.

Единственные команды, необходимые для регистра связи, помимо команд вызова и возврата, --- команды push и pop. Мы можем уменьшить количество команд в нелистовых функциях, сделав комбинированную команду для ``втолкнуть регистр связи, а затем вызвать функцию'', которая может использоваться для первого вызова функции в нелистовой функции, и другую команду, для ``вытолкнуть регистр связи, а затем выполнить возврат'', чтобы заканчивать нелистовую функцию. Однако это нарушает принцип, согласно которому мы хотим избежать сложных команд, чтобы упростить дизайн конвейера.

Единственный выигрыш в производительности, который мы получаем от использования регистра связи, состоит в экономии пропускной способности кэша из--за отсутствия сохранения адреса возврата для вызовов листовых функций.
Выигрыш этот не повлияет на производительность в приложениях, в которых пропускная способность кэша --- узкое место. Производительность команды возврата не оказывает влияния на пропускную способность кэша, поскольку может положиться на предсказание в буфере стека возврата.

Недостаток использования регистра связи заключается в том, что компилятор должен по--разному рассматривать листовые и нелистовые функции, и в том, что нелистовым функциям  нужны дополнительные команды для сохранения и восстановления регистра связи из стека.

Следовательно, мы не будем использовать в архитектуре ForwardCom регистр связи.

\subsubsection{Отдельный стек вызовов} \label{dualStack}
Мы можем иметь два стека: стек вызовов для адресов возврата, и стек данных, для локальных данных каждой функции. Программы без рекурсивных функций будут, как правило, иметь весьма ограниченную глубину стека вызовов, так что весь стек вызовов, или, по крайней мере, его \glqq горячая\grqq\ часть, может храниться на кристалле, что улучшит производительность, ибо для операций вызова и возврата не нужно будет ни операций с памятью, ни операций с кэшем, --- по крайней мере в критичном наиболее глубоко вложенном цикле программы. Также упростится предсказание адресов возврата, так как находящийся на кристалле кольцевой стек и буфер стека возврата будут одной и той же структурой.

Стек вызовов может быть реализован как кольцевой стек регистров на кристалле. Стек вызовов сбрасывается в память при переполнении. Команда возврата после такого события переполнения будет использовать значение на кристалле, а не значение в памяти, до тех пор, пока значение на кристалле не будет перезаписано новыми вызовами. Следовательно, событие сброса вряд ли должно возникать более одного раза в самой внутренней части программы.

Указатель для стека вызовов не должен быть регистром общего назначения, поскольку программисту редко нужно обращаться непосредственно к нему. Прямая манипуляция стеком вызовов нужна только при событии раскрутки стека (после исключения или long jump), либо при переключении задач.

У функции нет лёгкого способа обращения к адресу возврата, с которого она была вызвана. Сведения о вызывающем могут быть переданы явно, как параметр функции, в тех редких случаях, когда это необходимо. У сокрытия адреса возврата внутри процессора имеется достоинство с точки зрения безопасности: это мешает переписывать адрес возврата в случае программных ошибок или злонамеренных атак переполнением буфера.

Недостаток наличия отдельного стека вызовов состоит в том, что оно делает управление памятью более сложным, так как имеется два стека, которые потенциально могут переполниться. Для программ без рекурсивных функций размер стека вызова можно точно предсказать, используя метод, описанный на с.~\pageref{predictingStackSize}.

Отдельный стек вызовов может быть реализован в архитектуре ForwardCom. Размер накристалльного буфера стека и другие детали будут зависеть от реализации.

\subsubsection{Унифицированный стек вызова для адресов возврата и локальных данных} \label{singleStack}
Многие имеющиеся системы используют один и тот же стек и для адресов возврата, и для локальных данных. Данный метод может использоваться с архитектурой ForwardCom, поскольку прост в реализации. 

\subsubsection{Заключение для ForwardCom}
Система ForwardCom может использовать отдельный стек вызовов или унифицированный стек, но не регистр связи. Аппаратная реализация команд вызова и возврата зависит от того, имеется ли один или два стека. Система с двумя стеками будет использоваться для больших процессоров, которым важны производительность и безопасность, тогда как система с унифицированным стеком может использоваться в малых процессорах, где предпочтительнее простота. Микропроцессор ForwardCom не должен поддерживать обе системы, но должно программное обеспечение. Определённые на с.~\pageref{functionCallingConventions} соглашения вызова сделают программное обеспечение совместимым как с процессорами, имеющими один стек, так и с процессорами, имеющими два. Хвостовые вызовы могут быть эффективно реализованы одной командой перехода, независимо от типа стека.

\section{Вещественные ошибки и исключения}
Исключения  для вещественных ошибок по умолчанию --- запрещены, но их можно разрешить с помощью разрядов 26--29 численного регистра управления или регистра маски. Разрешённые исключения отлавливаются как ловушки (синхронные прерывания).

Проблема в том, что исключение, вызванное одним элементом вектора, вызовет прерывание обработки всего вектора. В случае ловушек, вызванных одним элементом вектора, поведение программы, использующей вещественные векторы, будет зависеть от длины вектора. Мы можем положиться на порождение и распространение значений NAN и INF, вместо ловушек, если мы хотим устойчивых результатов на разных процессорах с разными длинами векторов.

\label{nanPropagation}
Значения NAN будут распространяться по последовательности вещественных вычислений. Значение NAN может содержать двоичный шаблон диагностической информации, называемый полезной нагрузкой, и этот двоичный шаблон распространяется к результату. Проблема возникает, когда комбинируются два значения NAN, например, NAN1 + NAN2. Стандарт IEEE standard (754-2008) указывает лишь, что к результату распространяется один из двух операндов со значением NAN, что нарушает фундаментальный принцип коммутативности сложения. Результат может быть неустойчивым, когда компилятор меняет местами два операнда. Другая проблема со стандартом IEEE состоит в том, что значения NAN, согласно этому стандарту, не распространяются через операции max и min.

Здесь предлагается отклониться от этого неудачного стандарта, и выдавать, при комбинировании операндов NAN, комбинацию, с помощью поразрядного ИЛИ, полезных нагрузок значений NAN, что сделает распространение значений NAN более полезным и устойчивым. Разные разряды в NAN могут использоваться для указания разных сообщений об ошибках. Если в последовательности вычислений возникло много разных ошибочных условий, то все эти условия можно отследить в окончательном результате. Данное более хорошее распространение значений NAN разрешается установкой разряда 22 в численном регистре управления или в регистре маски.

Реализация будет использовать лишь один разряд в полезной нагрузке NAN для каждого условия ошибки. Тихое NAN имеет установленный разряд мантиссы с номером $\textit{количество_разрядов}-1$, тогда как остальные разряды доступны для любых полезных сведений. Если более хорошее распространение значений NAN разрешено разрядом 22 численного управляющего регистра или регистром маски, то процессор ForwardCom помещает диагностическую информацию в полезную нагрузку. Разряд мантиссы с номером $\textit{количество_разрядов}-2$ указывает на неверную арифметическую операцию, такую, как 0/0, $0\cdot\infty$, $\infty-\infty$, и т.п. Разряд с номером $\textit{количество_разрядов}-3$ указывает на квадратный корень из отрицательного числа или иные комплексные результаты. Оставшиеся разряды полезной нагрузки доступны для других целей, таких, как библиотеки функций.

Другие методы порождения сообщений об ошибках в библиотеках функций обсуждаются на с.~\pageref{errorMessageHandling}.

\section{Обнаружение целочисленного переполнения}\label{integerOverflowDetection}
Нет общепринятого стандартного метода обнаружения переполнения в целочисленных вычислениях. Обнаружение переполнения в операциях со знаковыми целыми числами в некоторых языках, вроде C++, --- реально ночной кошмар (см., например, \href{http://stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c}{stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c}). 

Было бы приятно иметь надёжный способ обнаружения целочисленного переполнения, и, вероятно, распространения его через последовательность вычислений, аналогичную распространению NAN для вещественных вычислений, так, чтобы ошибки можно было проверять в конце последовательности вычислений, а не после каждой операции. Компиляторы могли бы поддерживать этот метод, предлагая обнаружение переполнения блоком try/catch. Если аппаратура предложит разумный метод, то более вероятно, что компиляторы поддержат обнаружение целочисленного переполнения.

Предлагались следующие методы:
\begin{enumerate}
	\item Использовать несколько свободных разрядов регистров маски для обнаружения и распространения переполнения и других ошибок. У данного метода есть большое количество проблем, препятствующих неупорядоченному выполнению. Регистр маски будет использоваться не только как аргумент каждой команды, но и как результат. Каждая команда будет затем иметь два результата, а не один, что намного усложнит планировщик неупорядоченного выполнения, и вызовет нежелательные зависимости, когда один и тот же регистр маски используется для многих команд, которые иначе были бы независимы.
	
	\item Использовать элементы векторного регистра с нечётными номерами для нормальных вычислений над целыми числами, а следующие элементы с нечётными номерами --- для сведений о переполнении. Сведения о переполнении распространяются вместе с вычисленными значениями.	Данный метод будет эффективен для скалярных целочисленных вычислений, но расточителен для векторов, поскольку половина элементов вектора используется только для этой цели. 
	
	\item Использовать один элемент вектора для разрядов переполнения всех других элементов. Этот метод может быть заманчивым, поскольку тратит не столь много места, сколь предыдущий метод, но он уступает по производительности, из--за задержки переноса разрядов переполнения в дальнюю часть длинного вектора.
	
    \item Добавить в векторные регистры  дополнительные разряды для сведений о переполнении. У всех векторных регистров будет иметься один дополнительный разряд переполнения на каждые 32 разряда полезных данных. Эти разряды переполнения сохраняются, когда векторный регистр сохраняется и восстанавливается командами save\_cp и restore\_cp, но они теряются, когда вектор сохраняется как нормальные данные. Поведение разрядов переполнения управляется следующими разрядами численного управляющего регистра или регистра маски: \\
разряд №2: обнаруживать беззнаковое целочисленное переполнение; \\
разряд №3: обнаруживать знаковое целочисленное переполнение; \\
разряд №4: обнаруживать вещественное переполнение (экспериментально); \\
разряд №5: обнаруживать недопустимые вещественные операции (экспериментально); \\
разряд №6: распространять сведения о переполнении из входных операндов, применяя поразрядное ИЛИ результата текущей команды с разрядами переполнения  всех входных векторных регистровых операндов; нужно предоставить дополнительную команду для выделения разрядов переполнения из векторного регистра.

    \item В случае целочисленного переполнения порождать ловушку. Использовать регистр маски или численный управляющий регистр, как в методе 4. Разряд №7 разрешает ловушку при условиях, указанных разрядом №2 (беззнаковое целочисленное переполнение) или №3 (знаковое целочисленное переполнение). Данный метод требует несколько большего кода, но подвержен проблеме, заключающейся в том, что, как объяснялось в предыдущем разделе для вещественных ошибок, поведение векторного кода при возникновении ловушки зависит от длины вектора.
\end{enumerate}

Метод 2 здесь экспериментально поддерживается необязательными командами add\_oc и т.п., описанными на с.~\pageref{instructionsWithOverflowCheck}. 

Поддержка метода 4 может быть рассмотрена, поскольку она была бы более эффективной и полезной. Цена реализации метода 4 состоит в том, что в векторных регистрах нам нужно на 3\% больше разрядов; команды save\_cp и restore\_cp будут более сложными; а компилятор должен проверять переполнение перед сохранением векторов в памяти обычным способом.

Метод 5 следует поддержать. Он полезен для целочисленного кода в регистрах общего назначения и и для проверки, что переполнение не возникает в векторных регистрах.

Этими методами не следует обнаруживать переполнение в команд арифметики с насыщением  и в командах сдвига.

\section{Многопоточность}
Дизайн ForwardCom делает возможным реализацию очень больших векторных регистров, для обработки больших наборов данных. Однако есть практические ограничения на то, насколько сильно мы можем повысить производительность, используя б\'{о}льшие векторы. Во--первых, фактические структуры данных и алгоритмы часто ограничивают длину вектора, которая может использоваться. И, во--вторых, больш\'{и}е векторы означают б\'{о}льшие физические расстояния на полупроводниковом кристалле, и б\'{о}льшие транспортные задержки.

Дополнительный параллелизм можно получить, выполняя несколько потоков на каждом ядре ЦП. Дизайну следует допускать несколько ЦП на кристалле, или несколько ядер ЦП на одном и том же физическом кристалле.

Коммуникация между потоками и синхронизация потоков могут быть проблемами для производительности. Системе следует иметь эффективные средства для этих целей, включая спекулятивную синхронизацию.

Вероятно, не стоит допускать много потоков, одновременно разделяющих одно и то же ядро ЦП и кэш первого уровня (что Intel называет гиперпоточностью), ибо это могло бы разрешить потоку с низким приоритетом забрать ресурсы у потока с высоким приоритетом, и для операционной системы сложно определить, какие потоки могли бы конкурировать за одни и те же ресурсы выполнения, если они выполняются на одном и том же ядре ЦП.

\section{Свойства безопасности} \label{securityFeatures}
Безопасность включена в базовый дизайн и аппаратуры, и программного обеспечения. Она включает в себя следующие возможности.
\begin{itemize}
\item Гибкий и эффективный механизм защиты памяти.

\item Необязательное разделение стека вызовов и стека данных, так что адреса возврата не могут быть скомпрометированы переполнением буфера.

\item Каждый поток имеет своё собственное защищённое пространство памяти, за исключением совместимости с устаревшим программным обеспечением, требующим разделяемого пространства памяти для всех потоков приложения.

\item Драйвера устройств и системные функции имеют тщательно контролируемые права доступа. Эти функции не имеют общего доступа к памяти приложения, имея доступ лишь к конкретному блоку памяти, который приложение может разделять с системной функцией при её вызове. Драйвер устройства имеет доступ лишь к конкретному диапазону портов ввода--вывода и системных регистров, указанному в заголовке исполняемого файла и контролируемому ядром системы.

\item Обрушению драйвера устройства следует порождать не \glqq синий экран смерти\grqq, а сообщение об ошибке с закрытием приложения, его вызвавшего, и освобождение всех своих ресурсов.

\item Прикладные программы имеют доступ только к конкретным ресурсам, указанным в заголовке исполняемого файла, и контролируемых системой.

\item При использовании режима адресации со встроенной проверкой границ массива или условной ловушки проверка границ массивов --- проста и эффективна.

\item Различные необязательные методы проверки целочисленного переполнения.

\item Нет \glqq неопределённого\grqq\ поведения. Всегда имеется ограниченный набор допустимых реакций на ошибочное условие.
\end{itemize}

\subsection{Как улучшить безопасность приложений и систем}
Ниже перечислено несколько методов улучшения безопасности. Эти методы могут быть полезны в приложениях и операционных системах для ForwardCom, когда важна безопасность.

\subsubsection{Защита от переполнения буфера}
Входные буферы должны быть защищены от переполнения. Если программная защита недостаточна, то вы можете для входного буфера выделить изолированный блок памяти. См. с.~\pageref{isolatedMemoryBlocks}.

\subsubsection{Защита массивов} Следует проверять границы массивов.

\subsubsection{Защита от целочисленного переполнения} Используйте один из методов обнаружения целочисленного переполнения, упомянутых на с.~\pageref{integerOverflowDetection}.

\subsubsection{Защита памяти потока} Каждому потоку приложения следует иметь своё собственное защищённое пространство памяти. См. с.~\pageref{threadMemoryProtection}.

\subsubsection{Защита указателей кода}
Указатели на функции и другие указатели на код --- уязвимы для атак перехвата потока управления. Сюда входят атаки на следующее.
\begin{description}
\item[Адреса возврата.]	Адреса возврата, находящиеся в стеке, особенно уязвимы к атакам переполнения буфера. Используйте двухстековый дизайн для изоляции стека возврата от других данных.

\item[Таблицы переходов.] Многопутёвые ветвления switch/case часто реализуются как таблицы адресов перехода. Для этого следует использовать команду табличного перехода, с таблицей, помещённой в секцию CONST, с доступом только для чтения. См. с.~\pageref{jumpTableInstruction}.

\item[Таблицы виртуальны функций.] Языки программирования с объектным полиморфизмом, такие, как C++, используют таблицы указателей на виртуальные функции. Для них следует использовать команду табличного вызова, с таблицей, помещённой в секцию CONST, с доступом только для чтения. См. с.~\pageref{jumpTableInstruction}.

\item[Таблицы компоновки процедур.] Таблицы компоновки процедур, таблицы импорта, и символьное взаиморасположение в  ForwardCom не используются. См. с.~\pageref{libraryLinkMethods}.

\item[Указатели на функции обратного вызова.] Если функция принимает в качестве параметра функцию обратного вызова, то вместо сохранения в памяти сохраните его в регистре.

\item[Конечные автоматы.] Если конечный автомат или аналогичный алгоритм реализуется с помощью указателей на функции, то поместите эти указатели на функции в константный массив, используйте в качестве индекса этого массива переменную, в которой хранится состояние, и проверяйте индекс на переполнение. Компилятору следует иметь поддержку определения массива относительных указателей на функции в разделе CONST, и обращения к ним через команду табличного вызова.

\item[Другие указатели на функции.] Большинство случаев использования указателей на функции охватывается описанными выше методами. Других случаев в высокобезопасных приложениях следует избегать, либо указатели следует поместить в защищённые области памяти или области с непредсказываемыми адресами (см. \url{http://dslab.epfl.ch/proj/cpi/}).
\end{description}

\subsubsection{Управление правами доступа прикладных программ} 
В заголовок исполняемого файла прикладной программы следует включать сведения о том, какого рода операции приложению разрешены. Сюда могут включаться разрешения на различную сетевую активность, обращение к конкретным чувствительным файлам, разрешение на запись исполняемых файлов и скриптов, разрешение на установку драйверов, разрешение на порождение других процессов, разрешение на связь с другими процессами, и т.д. Пользователю следует иметь простой способ проверки наличия этих прав. Мы можем реализовать систему для управления правами доступа также и скриптов. Скрипты веб--страниц следует запускать в песочнице.

\subsubsection{Управление правами доступа драйверов устройств} 
Многие операционные системы предоставляют драйверам устройств очень большие права. Вместо наличия бюрократической централизованной системы согласования драйверов устройств, нам следует иметь более тщательное управление правами доступа каждого драйвера устройства. Команда системного вызова в ForwardCom даёт драйверу устройства доступ только к ограниченной области прикладной памяти (см. с.~\pageref{systemCallInstruction}). В заголовке исполняемого файла драйвера устройства следует иметь информацию о том, к каким портам и системным регистрам драйвер устройства имеет доступ. Пользователю следует иметь простой способ проверки наличия этих прав.

\subsubsection{Стандартизованная процедура установки} 
Защите от вредоносного программного обеспечения следует быть составной частью операционной системы, а не являться сторонним дополнением. Операционной системе следует предоставлять стандартизованный способ установки и удаления приложений. Системе следует отвергать запуск каких--либо программ, скриптов, или драйверов, которые не установлены с помощью этой процедуры. Это сделает для пользователя возможным просмотр прав, требуемых для всех устанавливаемых программ, и удаление любого вредоносного программного обеспечения, либо другого нежелательного программного обеспечения, с помощью обычной процедуры удаления.
\end{document}