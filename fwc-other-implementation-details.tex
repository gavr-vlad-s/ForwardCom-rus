% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Другие детали реализации}
\section{Порядок байтов} \label{endianness}
Организация памяти использует прямой порядок байтов (от младшего к старшему). Для чтения и записи файлов данных с обратным порядком байтов предоставляются команды смены порядка байтов.

\subsubsection{Обоснование}
Если бы использовалась организация с обратным порядком байтов, то способ хранения вектора в памяти зависел бы от размер элемента. Например, предположим, что у нас есть 128--разрядный векторный регистр, содержащий четыре 32--разрядных целых числа, обозначенные A, B, C, D. При использовании прямого порядка байтов, они хранились бы в памяти в следующем порядке:

%A0, A1, A2, A3, B0, B1, B2, B3, C0, C1, C2, C3, D0, D1, D2, D3,

\noindent 
где A0 --- самый младший байт числа A, а D3 --- самый старший байт числа D. При использовании же обратного порядка мы бы имели

A3, A2, A1, A0, B3, B2, B1, B0, C3, C2, C1, C0, D3, D2, D1, D0.

Этот порядок изменился бы, если бы тот же самый векторный регистр был организован, например, как восемь целых чисел, по 16 разрядов в каждом, или как два целых числа, по 64 разряда в каждом. Иными словами, нам бы потребовались разные команды чтения и записи для разных способов организации вектора.

Прямой порядок байтов более распространён по большому количеству причин, многократно обсуждавшихся в иных местах.

\section{Реализация стека вызовов} \label{callStackAlternatives}
Есть разные методы сохранения адресов возврата при вызовах функций: регистр связи, отдельный стек вызовов, или унифицированный стек, и для адресов возврата, и для локальных данных. Здесь мы обсудим достоинства и недостатки каждого из этих методов.

\subsubsection{Регистр связи}
Некоторые системы для хранения адреса возврата используют регистр связи. Преимущество регистра связи состоит в том, что листовые функции могут вызываться без сохранения чего--либо в стеке, что экономит пропускную способность кэша в программах с большим количеством вызовов листовых функций. Недостаток состоит в том, что каждой нелистовой функции нужно перед вызовом другой функции сохранять регистр связи в стеке, и восстанавливать  его перед возвратом.

Если бы мы приняли решение использовать регистр связи, то им должен был бы быть специальный регистр, а не один из регистров общего назначения. Регистру связи не нужно поддерживать все вещи, которые можно делать с регистром общего назначения. Если регистр связи включается как один из регистров общего назначения, то у программиста возникнет соблазн сохранить регистр связи в другом регистре, а не в стеке, и затем, в конце функции, перейти по адресу, хранящемуся в том другом регистре. Это, конечно, работать будет, но помешает способам, которыми предсказываются возвраты. Модуль предсказания ветвления использует специальный механизм для предсказания возвратов, отличающийся от механизма, используемого для предсказания иных переходов и ветвлений. Данный механизм, называемый буфером стека возврата, представляет собой небольшой кольцевой кэш, запоминающий адреса последних вызовов. Если функция выполняет возврат переходом по адресу, содержащемуся в регистре, отличном от регистра связи, то она будет использовать ошибочный механизм предсказания, что вызовет большие задержки из--за неверного предсказания последующей серии возвратов. Буфер стека возврата также будет перепутан, если регистр связи используется для косвенного перехода или в иных целях.

Единственные команды, необходимые для регистра связи, помимо команд вызова и возврата, --- команды push и pop. Мы можем уменьшить количество команд в нелистовых функциях, сделав комбинированную команду для ``втолкнуть регистр связи, а затем вызвать функцию'', которая может использоваться для первого вызова функции в нелистовой функции, и другую команду, для ``вытолкнуть регистр связи, а затем выполнить возврат'', чтобы заканчивать нелистовую функцию. Однако это нарушает принцип, согласно которому мы хотим избежать сложных команд, чтобы упростить дизайн конвейера.

Единственный выигрыш в производительности, который мы получаем от использования регистра связи, состоит в экономии пропускной способности кэша из--за отсутствия сохранения адреса возврата для вызовов листовых функций.
Выигрыш этот не повлияет на производительность в приложениях, в которых пропускная способность кэша --- узкое место. Производительность команды возврата не оказывает влияния на пропускную способность кэша, поскольку может положиться на предсказание в буфере стека возврата.

Недостаток использования регистра связи заключается в том, что компилятор должен по--разному рассматривать листовые и нелистовые функции, и в том, что нелистовым функциям  нужны дополнительные команды для сохранения и восстановления регистра связи из стека.

Следовательно, мы не будем использовать в архитектуре ForwardCom регистр связи.

\subsubsection{Отдельный стек вызовов} \label{dualStack}
Мы можем иметь два стека: стек вызовов для адресов возврата, и стек данных, для локальных данных каждой функции. Программы без рекурсивных функций будут, как правило, иметь весьма ограниченную глубину стека вызовов, так что весь стек вызовов, или, по крайней мере, его \glqq горячая\grqq\ часть, может храниться на кристалле, что улучшит производительность, ибо для операций вызова и возврата не нужно будет ни операций с памятью, ни операций с кэшем, --- по крайней мере в критичном наиболее глубоко вложенном цикле программы. Также упростится предсказание адресов возврата, так как находящийся на кристалле кольцевой стек и буфер стека возврата будут одной и той же структурой.

Стек вызовов может быть реализован как кольцевой стек регистров на кристалле. Стек вызовов сбрасывается в память при переполнении. Команда возврата после такого события переполнения будет использовать значение на кристалле, а не значение в памяти, до тех пор, пока значение на кристалле не будет перезаписано новыми вызовами. Следовательно, событие сброса вряд ли должно возникать более одного раза в самой внутренней части программы.

Указатель для стека вызовов не должен быть регистром общего назначения, поскольку программисту редко нужно обращаться непосредственно к нему. Прямая манипуляция стеком вызовов нужна только при событии раскрутки стека (после исключения или long jump), либо при переключении задач.

У функции нет лёгкого способа обращения к адресу возврата, с которого она была вызвана. Сведения о вызывающем могут быть переданы явно, как параметр функции, в тех редких случаях, когда это необходимо. У сокрытия адреса возврата внутри процессора имеется достоинство с точки зрения безопасности: это мешает переписывать адрес возврата в случае программных ошибок или злонамеренных атак переполнением буфера.

Недостаток наличия отдельного стека вызовов состоит в том, что оно делает управление памятью более сложным, так как имеется два стека, которые потенциально могут переполниться. Для программ без рекурсивных функций размер стека вызова можно точно предсказать, используя метод, описанный на с.~\pageref{predictingStackSize}.

Отдельный стек вызовов может быть реализован в архитектуре ForwardCom. Размер накристалльного буфера стека и другие детали будут зависеть от реализации.

\subsubsection{Унифицированный стек вызова для адресов возврата и локальных данных} \label{singleStack}
Многие имеющиеся системы используют один и тот же стек и для адресов возврата, и для локальных данных. Данный метод может использоваться с архитектурой ForwardCom, поскольку прост в реализации. 

\subsubsection{Заключение для ForwardCom}
Система ForwardCom может использовать отдельный стек вызовов или унифицированный стек, но не регистр связи. Аппаратная реализация команд вызова и возврата зависит от того, имеется ли один или два стека. Система с двумя стеками будет использоваться для больших процессоров, которым важны производительность и безопасность, тогда как система с унифицированным стеком может использоваться в малых процессорах, где предпочтительнее простота. Микропроцессор ForwardCom не должен поддерживать обе системы, но должно программное обеспечение. Определённые на с.~\pageref{functionCallingConventions} соглашения вызова сделают программное обеспечение совместимым как с процессорами, имеющими один стек, так и с процессорами, имеющими два. Хвостовые вызовы могут быть эффективно реализованы одной командой перехода, независимо от типа стека.

\section{Вещественные ошибки и исключения}
Исключения  для вещественных ошибок по умолчанию --- запрещены, но их можно разрешить с помощью разрядов 26--29 численного регистра управления или регистра маски. Разрешённые исключения отлавливаются как ловушки (синхронные прерывания).

Проблема в том, что исключение, вызванное одним элементом вектора, вызовет прерывание обработки всего вектора. В случае ловушек, вызванных одним элементом вектора, поведение программы, использующей вещественные векторы, будет зависеть от длины вектора. Мы можем положиться на порождение и распространение значений NAN и INF, вместо ловушек, если мы хотим устойчивых результатов на разных процессорах с разными длинами векторов.

\label{nanPropagation}
Значения NAN будут распространяться по последовательности вещественных вычислений. Значение NAN может содержать двоичный шаблон диагностической информации, называемый полезной нагрузкой, и этот двоичный шаблон распространяется к результату. Проблема возникает, когда комбинируются два значения NAN, например, NAN1 + NAN2. Стандарт IEEE standard (754-2008) указывает лишь, что к результату распространяется один из двух операндов со значением NAN, что нарушает фундаментальный принцип коммутативности сложения. Результат может быть неустойчивым, когда компилятор меняет местами два операнда. Другая проблема со стандартом IEEE состоит в том, что значения NAN, согласно этому стандарту, не распространяются через операции max и min.

Здесь предлагается отклониться от этого неудачного стандарта, и выдавать, при комбинировании операндов NAN, комбинацию, с помощью поразрядного ИЛИ, полезных нагрузок значений NAN, что сделает распространение значений NAN более полезным и устойчивым. Разные разряды в NAN могут использоваться для указания разных сообщений об ошибках. Если в последовательности вычислений возникло много разных ошибочных условий, то все эти условия можно отследить в окончательном результате. Данное более хорошее распространение значений NAN разрешается установкой разряда 22 в численном регистре управления или в регистре маски.

Реализация будет использовать лишь один разряд в полезной нагрузке NAN для каждого условия ошибки. Тихое NAN имеет установленный разряд мантиссы с номером $\textit{количество_разрядов}-1$, тогда как остальные разряды доступны для любых полезных сведений. Если более хорошее распространение значений NAN разрешено разрядом 22 численного управляющего регистра или регистром маски, то процессор ForwardCom помещает диагностическую информацию в полезную нагрузку. Разряд мантиссы с номером $\textit{количество_разрядов}-2$ указывает на неверную арифметическую операцию, такую, как 0/0, $0\cdot\infty$, $\infty-\infty$, и т.п. Разряд с номером $\textit{количество_разрядов}-3$ указывает на квадратный корень из отрицательного числа или иные комплексные результаты. Оставшиеся разряды полезной нагрузки доступны для других целей, таких, как библиотеки функций.

Другие методы порождения сообщений об ошибках в библиотеках функций обсуждаются на с.~\pageref{errorMessageHandling}.

\section{Обнаружение целочисленного переполнения}\label{integerOverflowDetection}
Нет общепринятого стандартного метода обнаружения переполнения в целочисленных вычислениях. Обнаружение переполнения в операциях со знаковыми целыми числами в некоторых языках, вроде C++, --- реально ночной кошмар (см., например, \href{http://stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c}{stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c}). 

Было бы приятно иметь надёжный способ обнаружения целочисленного переполнения, и, вероятно, распространения его через последовательность вычислений, аналогичную распространению NAN для вещественных вычислений, так, чтобы ошибки можно было проверять в конце последовательности вычислений, а не после каждой операции. Компиляторы могли бы поддерживать этот метод, предлагая обнаружение переполнения блоком try/catch. Если аппаратура предложит разумный метод, то более вероятно, что компиляторы поддержат обнаружение целочисленного переполнения.

Предлагались следующие методы:
\begin{enumerate}
	\item Использовать несколько свободных разрядов регистров маски для обнаружения и распространения переполнения и других ошибок. У данного метода есть большое количество проблем, препятствующих неупорядоченному выполнению. Регистр маски будет использоваться не только как аргумент каждой команды, но и как результат. Каждая команда будет затем иметь два результата, а не один, что намного усложнит планировщик неупорядоченного выполнения, и вызовет нежелательные зависимости, когда один и тот же регистр маски используется для многих команд, которые иначе были бы независимы.
	
	\item Использовать элементы векторного регистра с нечётными номерами для нормальных вычислений над целыми числами, а следующие элементы с нечётными номерами --- для сведений о переполнении. Сведения о переполнении распространяются вместе с вычисленными значениями.	Данный метод будет эффективен для скалярных целочисленных вычислений, но расточителен для векторов, поскольку половина элементов вектора используется только для этой цели. 
	
	\item Использовать один элемент вектора для разрядов переполнения всех других элементов. Этот метод может быть заманчивым, поскольку тратит не столь много места, сколь предыдущий метод, но он уступает по производительности, из--за задержки переноса разрядов переполнения в дальнюю часть длинного вектора.
	
    \item Добавить в векторные регистры  дополнительные разряды для сведений о переполнении. У всех векторных регистров будет иметься один дополнительный разряд переполнения на каждые 32 разряда полезных данных. Эти разряды переполнения сохраняются, когда векторный регистр сохраняется и восстанавливается командами save\_cp и restore\_cp, но они теряются, когда вектор сохраняется как нормальные данные. Поведение разрядов переполнения управляется следующими разрядами численного управляющего регистра или регистра маски: \\
разряд №2: обнаруживать беззнаковое целочисленное переполнение; \\
разряд №3: обнаруживать знаковое целочисленное переполнение; \\
разряд №4: обнаруживать вещественное переполнение (экспериментально); \\
разряд №5: обнаруживать недопустимые вещественные операции (экспериментально); \\
разряд №6: распространять сведения о переполнении из входных операндов, применяя поразрядное ИЛИ результата текущей команды с разрядами переполнения  всех входных векторных регистровых операндов; нужно предоставить дополнительную команду для выделения разрядов переполнения из векторного регистра.

    \item В случае целочисленного переполнения порождать ловушку. Использовать регистр маски или численный управляющий регистр, как в методе 4. Разряд №7 разрешает ловушку при условиях, указанных разрядом №2 (беззнаковое целочисленное переполнение) или №3 (знаковое целочисленное переполнение). Данный метод требует несколько большего кода, но подвержен проблеме, заключающейся в том, что, как объяснялось в предыдущем разделе для вещественных ошибок, поведение векторного кода при возникновении ловушки зависит от длины вектора.
\end{enumerate}

Метод 2 здесь экспериментально поддерживается необязательными командами add\_oc и т.п., описанными на с.~\pageref{instructionsWithOverflowCheck}. 

Поддержка метода 4 может быть рассмотрена, поскольку она была бы более эффективной и полезной. Цена реализации метода 4 состоит в том, что в векторных регистрах нам нужно на 3\% больше разрядов; команды save\_cp и restore\_cp будут более сложными; а компилятор должен проверять переполнение перед сохранением векторов в памяти обычным способом.

Метод 5 следует поддержать. Он полезен для целочисленного кода в регистрах общего назначения и и для проверки, что переполнение не возникает в векторных регистрах.

Этими методами не следует обнаруживать переполнение в команд арифметики с насыщением  и в командах сдвига.

\section{Многопоточность}
%The ForwardCom design makes it possible to implement very large vector registers to process large data sets. However, there are practical limits to how much you can speed up the performance by using larger vectors. First, the actual data structures and algorithms often limit the vector length that can be used. And second, large vectors mean longer physical distances on the semiconductor chip and longer transport delays.
%\vspace{2mm}
%
%Additional parallelism can be obtained by running multiple threads in each their CPU core. The design should allow multiple CPU chips or multiple CPU cores on the same physical chip.
%\vspace{2mm}
%
%Communication and synchronization between threads can be a performance problem. The system should have efficient means for these purposes, including speculative synchronization.
%\vspace{2mm}
%
%It is probably not worthwhile to allow multiple threads to share the same CPU core and level-1 cache simultaneously (this is what Intel calls hyper-threading) because this could allow a low priority thread to steal resources from a high priority thread, and it is difficult for the operating system to determine which threads might be competing for the same execution resources if they are run in the same CPU core.
%\vspace{2mm}
%
%\section{Security features} \label{securityFeatures}
%Security is included in the fundamental design of both hardware and software. This includes the following features.
%
%\begin{itemize}
%\item A flexible and efficient memory protection mechanism.
%
%\item Optional separation of call stack and data stack so that return addresses cannot be compromised by buffer overflow.
%
%\item Each thread has its own protected memory space, except where compatibility with legacy 
%software requires a shared memory space for all threads in an application.
%
%\item Device drivers and system functions have carefully controlled access rights. These functions do not have general access to application memory, but only to a specific block of memory that an application may share with a system function when calling it. A device driver has only access to a specific range of input/output ports and system registers as specified in the executable file header and controlled by the system core.
%
%\item A fault in a device driver should not generate a ``blue screen of death'', but generate an error message and close the application that called it and free its resources.
%
%\item Application programs have only access to specific resources as specified in the executable file header and controlled by the system.
%
%\item Array bounds checking is simple and efficient, using an addressing mode with built-in bounds checking or a conditional trap.
%
%\item Various optional methods for checking integer overflow.
%
%\item There is no ``undefined'' behavior. There is always a limited set of permissible responses to an error condition.
%\end{itemize}
%
%\subsection{How to improve the security of applications and systems}
%Several methods for improving security are listed below. These methods may be useful in ForwardCom applications and operating systems where security is important.
%
%\subsubsection{Protect against buffer overflow}
%Input buffers must be protected against overflow. If a software-based protection is not sufficient then you may allocate an isolated block of memory for the input buffer. See page \pageref{isolatedMemoryBlocks}.
%
%\subsubsection{Protect arrays} Array bounds should be checked.
%
%\subsubsection{Protect against integer overflow} Use one of the methods for detecting integer overflow mentioned on page \pageref{integerOverflowDetection}.
%
%\subsubsection{Protect thread memory} Each thread in an application should have its own protected memory space. See page \pageref{threadMemoryProtection}.
%
%\subsubsection{Protect code pointers}
%Function pointers and other pointers to code are vulnerable to control flow hijack attacks. These include:
%
%\begin{description}
%\item[Return addresses.] Return addresses on the stack are particularly vulnerable to buffer overflow attacks. Use a dual stack design to isolate the return stack from other data.
%
%\item[Jump tables.] Switch/case multiway branches are often implemented as tables of jump addresses. These should use the jump table instruction with the table placed in the CONST section with read-only access. See page \pageref{jumpTableInstruction}.
%
%\item[Virtual function tables.] Programming languages with object polymorphism, such as C++, use tables of pointers to virtual functions. These should use the call table instruction with the table placed in the CONST section with read-only access. See page \pageref{jumpTableInstruction}.
%
%\item[Procedure linkage tables.] Procedure linkage tables, import tables and symbol interposition are not used in ForwardCom. See page \pageref{libraryLinkMethods}.
%
%\item[Callback function pointers.] If a function receives a pointer to a callback function as parameter, then keep this pointer in a register rather than saving it to memory.
%
%\item[State machines.] If a state machine or similar algorithm is implemented with function pointers then place these function pointers in a constant array, use a state variable as index into this array and check the index for overflow. The compiler should have support for defining an array of relative function pointers in the CONST section and access them with the call table instruction.
%
%\item[Other function pointers.] Most uses of function pointers can be covered by the methods described above. Other uses of function pointers should be avoided in high security applications, or the pointers should be placed in protected memory areas or with unpredictable addresses. (See
%\href{http://dslab.epfl.ch/proj/cpi/}{Code-Pointer Integrity link}).
%
%\end{description}
%
%\subsubsection{Control access rights of application programs} 
%The executable file header of an application program should include information about which kinds of operations the application needs permission to. This may include permission to various network activities, access to particular sensitive files, permission to write executable files and scripts, permission to install drivers, permission to spawn other processes, permission to inter-process communication, etc. The user should have a simple way of checking if these access rights are acceptable. We may implement a system for controlling the access rights of scripts as well. Web page scripts should run in a sandbox.
%
%\subsubsection{Control access rights of device drivers} 
%Many operating systems are giving very extensive rights to device drivers. Rather than having a bureaucratic centralized system for approval of device drivers, we should have a more careful control of the access rights of each device driver. The system call instruction in ForwardCom gives a device driver access to only a limited area of application memory (see page \pageref{systemCallInstruction}). The executable file header of a device driver should have information about which ports and system registers the device driver has access to. The user should have a simple way of checking if these access rights are acceptable.
%
%\subsubsection{Standardized installation procedure} 
%Malware protection should be an integral part of the operating system, not a third-party add on. The operating system should provide a standardized way of installing and uninstalling applications. The system should refuse to run any program, script or driver that has not been installed through this procedure. This will make it possible for the user to review the access requirements of all installed programs and to remove any malware or other unwanted software through the normal uninstallation procedure.
\end{document}