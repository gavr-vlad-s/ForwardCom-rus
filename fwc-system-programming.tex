% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Системное программирование}
Системные команды еще не полностью определены. Имеется больше работы по созданию эффективного дизайна системы. Однако первые экспериментальные реализации ForwardCom будут без операционной системы, поэтому дизайн системы ещё не исправлен. Предпочтительнее потратить больше времени на оптимизацию дизайна системы, а не на определение полного стандарта на данной ранней стадии разработки.

Следует иметь по крайней мере три разных уровня привилегий:
\begin{itemize}
\item  Ядро системы, имеющее высочайший уровень привилегий. Управление памятью и планирование потоков размещаются здесь. Это единственная часть, которая может модифицировать карту памяти и управлять правами доступа на более низких уровнях.

\item Драйвера устройств и подключаемые модули системы имеют тщательно управляемые права доступа. Структура, подобная карте памяти (см. с.~\pageref{memoryManagement}) даёт драйверу устройства доступ к конкретному диапазону необходимых драйверу портов ввода--вывода и системных регистров. Пользовательское приложение может дать драйверу устройства права на чтение и запись для конкретного диапазона памяти данных, которым оно владеет. Это выполняется через команду системного вызова. У драйвера устройства нет прав на память кода вызвавшего его приложения. Последнее означает, что указатели на функции обратного вызова с системными вызовами использоваться не могут.

\item Прикладная программа имеет доступ только к памяти, которая ею выделена или с ней разделяется. Память, принадлежащая потоку, обычно не разделяется с другими потоками того же процесса. Прикладные программы имеют доступ к немногим системным регистрам и не имеют доступа к портам ввода--вывода.
\end{itemize}

Переходы между этими уровнями управляются командами системного вызова и системного возврата, а также ловушками и прерываниями.

Для целей управления имеются различные системные регистры. Дополнительно имеется два набора регистров, используемых для временного хранения, один набор --- для уровня драйверов устройств, и один --- для уровня ядра системы. Временные регистры для уровня драйверов устройств при каждом вызове драйвера устройства очищаются, по причинам, связанным с безопасностью. Эти регистры, в основном, используются для временного сохранения регистров общего назначения.

\section{Карта памяти}
Имеется три вида доступа к памяти: чтение, запись, и выполнение. Эти виды доступа различны, но могут комбинироваться. Например, доступ на выполнение не влечёт доступа по чтению. Доступ на запись и доступ на выполнение обычно комбинировать не следует, поскольку самомодифицирующийся код --- отталкивающ.

Карта памяти сохраняется на кристалле ЦП. Каждый элемент имеет три поля: виртуальный адрес (вплоть до 64 разрядов), права доступа (3 разряда), и слагаемое для трансляции адреса (вплоть до 64 разрядов). Разбиения памяти на страницы нет. Вместо этого имеются блоки памяти переменных размеров.

Элементы карты памяти обязаны всё время храниться в отсортированном виде, так, чтобы каждый блок памяти заканчивался там, где начинается следующий блок. Адреса обязательно должны быть кратны 8. Каждый поток имеет свою собственную карту памяти. Типичная карта памяти для потока приложения может выглядеть примерно так:

\begin{longtable} {|p{22mm}|p{30mm}|l|p{80mm}|}
\caption{Пример карты памяти} \\
\endfirsthead
\endhead
\hline
\bfseries Начальный адрес & \bfseries Права & \bfseries Слагаемое & \bfseries Комментарий  \\ \hline
0x10000                   & чтение          & 0                   & Секция CONST.\\
0x10100                   & выполнение      & 0                   & Секция CODE. \\
0x10800                   & нет             & 0                   & Принадлежит другим процессам. \\
0x20000                   & чтение, запись  & 0                   & Основные разделы STACK, DATA, BSS, HEAP. \\
0x24000                   & нет             & 0                   & Принадлежит другим процессам. \\
0x30000                   & чтение, запись  & 0                   & Секция STACK потока, блок окружения потока, и статические данные потока. \\
0x32000                   & нет             & 0                   & Остальное принадлежит другим процессам. \\ \hline
\end{longtable}

Может быть некоторое количество дополнительных элементов, для блоков памяти, разделяемых между процессами, и для безопасно изолированных блоков памяти. В случае, когда память становится фрагментированной, блок виртуальной памяти может иметь несколько элементов. Слагаемые используются для того, чтобы сохранить виртуальные адреса блоков смежными, в то время как физические адреса смежными не являются. Начальные адреса ---  это адреса в виртуальной памяти.

Размер карты памяти --- переменный. Максимальный размер зависит от реализации. На кристалле имеется по меньшей мере три карты памяти, по одной для каждого уровня привилегий, что делает переходы между уровнями быстрыми. Пространство на кристалле, используемое для карты памяти. Область на кристалле, используемая для карт памяти, может быть реконфигурируемой, так что в случае, когда карты памяти малы, карты памяти многих процессов могут оставаться на кристалле.

Карты памяти управляются уровнем ядра системы. Команды read\_memory\_map и write\_memory\_map используют механизм векторного цикла для быстрой манипуляции картами памяти.

Методы устранения фрагментации памяти, описанные на с.~ \pageref{memoryManagement}, важны для сохранения карт памяти малыми.

Переключения задач будут очень быстрыми, поскольку мы заменили большие таблицы страниц и буферы ассоциативной трансляции (translation-lookaside-buffer, TLB) традиционных систем малой хранящейся на кристалле картой памяти, что делает систему подходящей для операционных систем реального времени.

\section{Стек вызовов}
Возможно наличие либо унифицированного стека (и для данных функций, и для адресов возврата), либо двух отдельных стеков. См. с.~\pageref{callStackAlternatives}. В настоящее время ForwardCom поддерживает обе системы. Двухстековая система --- безопаснее и эффективнее, тогда как одностековая система может использоваться для малых процессоров, где предпочтительнее более простая одностековая система.

У двухстековой системы имеется стек вызовов, сохраняемый внутри ЦП, а не в ОЗУ. Требуется метод сохранения этого стека, когда он заполнен. Данный метод схож с методом, используемым для сохранения карты памяти, как описано выше, использующим векторные обращения к памяти. Должна быть возможна манипуляция со стеком вызовов, для переключений задач и для раскрутки стека в обработчике исключения.

\section{Системные вызовы и системные функции} \label{systemCallIDSystem}
Вызовы системных функций выполняются с помощью команды системного вызова (sys\_call). Команда системного вызова использует не адреса, а номера, ID. Каждый номер (ID) состоит из (в младшей половине) ID функции, и (в старшей половине) ID модуля. ID модуля идентифицирует модуль системы или драйвер устройства. У ядра системы ID = 0. Каждая часть ID может быть либо 16--разрядной, либо 32--разрядной, так что скомбинированный ID может быть либо 32--разрядным, либо 64--разрядным.

Дополнительным модулям системы и драйверам устройств нет необходимости иметь фиксированные номера ID, поскольку это потребовало бы некоторого центрального авторитета, присваивающего эти номера. Вместо этого программа будет должна запросить номер ID, задав имя модуля. Функции в пределах модуля могут иметь фиксированные или переменные номера ID.

Будет системная функция (с фиксированным номером ID), принимающая в качестве аргументов имя модуля и функции, и возвращающая номер ID. Номер ID  таким способом может быть подобран при первом вызове этой функции.

Номер ID системной функции может быть помещён в программу тремя способами:
\begin{enumerate}
\item Наиболее важные системные функции имеют фиксированные номера ID, которые можно вставить во время компиляции.

\item Номер ID может быть найден во время загрузки, тем же способом, что и при компоновке во время загрузки. Это описано на с.~\pageref{loadTimeLinking}. Загрузчик найдёт номер ID и вставит его в код перед запуском программы.

\item Номер ID находится во время выполнения, перед первым вызовом желаемой функции. 
\end{enumerate}

Соглашения вызова для системных функций --- те же, что и для других функций, использующих регистры для параметров и для возврата значения. Регистры, используемые для параметров, определяются общим соглашением вызова. Соглашения вызова описаны на с.~\pageref{functionCallingConventions}. Регистры для параметров не следует путать с операндами для команды системного вызова.

Команда системного вызова имеет три операнда. Первый операнд --- скомбинированный ID, помещённый в регистр (RT) или в непосредственно заданную константу. Второй операнд (RD) --- указатель на блок памяти, который может быть использован для передачи данных между вызывающей программой и системной функцией. Третий параметр (RS) --- размер этого блока памяти. Последние два параметра должны быть кратны 8. 

Вызывающий поток обязан иметь право на доступ к блоку памяти, который он разделяет с системной функцией. Это может быть право на чтение, право на запись, или и на то, и на другое. Эти права доступа передаются системной функции. У системной функции нет прав доступа ни к какой другой части памяти приложения.

С системными вызовами невозможно использовать указатели на функции обратного вызова, поскольку исполняемая память с системной функцией разделяться не может. Вместо этого системная функция может вызвать экспортируемую функцию, предоставляемую приложением, используя метод для межпроцессных вызовов, описанный ниже.

Функциям драйвера устройства предпочтительнее иметь отдельные стеки. Системный вызов идёт сначала в ядро системы, которое назначает стек для функции драйвера устройства и создаёт карту памяти для неё перед перенаправлением вызова на желаемую функцию. Во время этого перенаправления предпочтительнее не использовать никакого стека. Два регистра, идентифицирующих блок разделяемой памяти, копируются в специальные регистры, доступные вызванной функции. Системная функция выполняется в том же потоке, что и вызвавшее её приложение, но не с тем же самым стеком. 

Старые значения указателя команд, указателя стека, регистра DATAP и карты памяти сохраняются в системных регистрах, чтобы быть восстановленными командой системного возврата. 

Системным функциям, драйверам устройств, и обработчикам прерываний разрешается использовать все регистры общего назначения и векторные регистры, если они сохраняются и восстанавливаются согласно нормальным соглашениям вызова. Обработчики прерываний обязаны сохранять и восстанавливать все регистры, которые они используют.

Предоставляется метод для получения сведений об использовании регистров системной функцией, так что возможен их вызов с помощью соглашений об использовании регистров или методом 1, или методом 2, описанным на с.~\pageref{registerUsageConvention}. Использование стека системными функциями не имеет никакого отношения к вызывающему, ибо они не используют стек вызова прикладной программы.

Некоторые важные системные функции обязательно должны быть стандартизированы и доступны во всех операционных системах, что сделает возможным, например, создание сторонней библиотеки функций, работающей во всех операционных системах, даже если этой библиотеке нужно вызывать системные функции. Это также облегчит адаптацию программ для разных операционных систем. Список системных функций, которые могли бы быть стандартизированы, включает функции для создания потоков, синхронизации потоков, установки приоритета потоков, выделения памяти, измерения времени, системные сведения, обращение к переменным окружения, и т.д.

Следовало бы отобрать системные библиотеки, предоставляющие наиболее распространённые виды пользовательского интерфейса, такие, как графический пользовательский интерфейс, консольный режим, и серверный режим. Эти библиотеки пользовательского интерфейса следует предоставлять для каждой операционной системы, которая может работать на нашей архитектуре, так что одна и та же исполняемая программа может работать в разных операционных системах, просто посредством компоновки, в момент загрузки, с подходящей библиотекой пользовательского интерфейса. Такие библиотеки пользовательского интерфейса могут быть основаны на существующих платформенно--независимых библиотеках GUI, таких, как, например, wxWidgets или QT. Все библиотеки пользовательского интерфейса обязаны поддерживать функцию error\_message, упомянутую ниже. 

\section{Межпроцессные вызовы} \label{interProcessCalls}
%Inter-process calls are mediated by a system function. This works in the following way. An application program can export a function with an entry in its executable file header. Another application can get access to this exported function by calling a system function that checks for permission and switches the memory map, the DATAP and THREADP registers and the stack pointer before calling the exported function, and switches back before returning to the caller. The call will appear as a separate thread to the called program. The general purpose registers and vector registers can be used for parameters and return value in the same was as for normal functions. This mechanism does not generate any shared memory between caller and callee. Therefore, the exported function must use only simple types that fit into registers for its parameters and return type. A block of memory can be shared between the two processes as described on page \pageref{sharedMemory}. 
%
%\section{Error message handling} \label{errorMessageHandling}
%There is a need for a standardized way of reporting errors that occur in a program. Many current systems fail to satisfy this need, or they use methods that are not portable or thread-safe. In particular, the following situations would benefit from such a standard. 
%
%\begin{enumerate}
%\item A function library detects an error, for example an invalid parameter, and needs to report the error to the calling program. The calling program will decide whether to recover from the error or terminate. 
%
%\item A trap is generated because of a numerical error. The program fails to catch it as an exception, or the programming language has no support for structured exception handling. The operating system must make an informative error message. 
%
%\item A program can run in different environments that require different forms of error handling. 
%
%\item A function library in source code form, a class library, or any other piece of code needs to report an error without knowing which user interface paradigm is used (e. g. console mode or graphical user interface). It needs a standardized way of reporting the error to the operating system or to the user interface framework, which must present an error 
%message to the user in the way that is appropriate for the user interface (e. g. pop up a message box, print to stderr, print to a log file, or send a message to an administrator).
%\end{enumerate}
%
%\label{errorReportFunction}
%It is proposed to define a standard library function named error\_message for this purpose. All user interface frameworks must define this function. It is possible to automatically choose between different versions of this function at run time depending on system settings, using the function dispatch feature described on page \pageref{libraryFunctionDispatchSystem}. The main program may override this function by defining its own function with the same name. 
%\vspace{2mm}
%
%The error\_message function must have the following parameters: a numerical error code, a string pointer giving an error message, and another string pointer giving the name of the function where the error occurred. These strings are coded as zero-terminated UTF-8 strings. 
%The error message is in the English language by default. It is not reasonable to require support for many different languages (see 
%\href{https://en.wikibooks.org/wiki/Usability_for_Nerds/Software/Internationalization}{this link} for a discussion of problems with internationalization). Instead, a manual in the desired language can contain a list of error codes. 
%\vspace{2mm}
%
%The error message string may include numerical values and diagnostic information, such as the value of a parameter that is out of range.
%\vspace{2mm}
%
%The error\_message function may or may not return. If it returns then the function that called it must return in a graceful way. The error\_message function may alternatively terminate the application or it may raise an exception or trap which is handled by the operating system in case the exception is not caught by the program. 
\end{document}