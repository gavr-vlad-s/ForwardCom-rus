% chapter included in forwardcom.tex
\documentclass[forwardcom.tex]{subfiles}
\begin{document}
\chapter{Системное программирование}
Системные команды еще не полностью определены. Имеется больше работы по созданию эффективного дизайна системы. Однако первые экспериментальные реализации ForwardCom будут без операционной системы, поэтому дизайн системы ещё не исправлен. Предпочтительнее потратить больше времени на оптимизацию дизайна системы, а не на определение полного стандарта на данной ранней стадии разработки.

Следует иметь по крайней мере три разных уровня привилегий:
\begin{itemize}
\item  Ядро системы, имеющее высочайший уровень привилегий. Управление памятью и планирование потоков размещаются здесь. Это единственная часть, которая может модифицировать карту памяти и управлять правами доступа на более низких уровнях.

\item Драйвера устройств и подключаемые модули системы имеют тщательно управляемые права доступа. Структура, подобная карте памяти (см. с.~\pageref{memoryManagement}) даёт драйверу устройства доступ к конкретному диапазону необходимых драйверу портов ввода--вывода и системных регистров. Пользовательское приложение может дать драйверу устройства права на чтение и запись для конкретного диапазона памяти данных, которым оно владеет. Это выполняется через команду системного вызова. У драйвера устройства нет прав на память кода вызвавшего его приложения. Последнее означает, что указатели на функции обратного вызова с системными вызовами использоваться не могут.

\item Прикладная программа имеет доступ только к памяти, которая ею выделена или с ней разделяется. Память, принадлежащая потоку, обычно не разделяется с другими потоками того же процесса. Прикладные программы имеют доступ к немногим системным регистрам и не имеют доступа к портам ввода--вывода.
\end{itemize}

Переходы между этими уровнями управляются командами системного вызова и системного возврата, а также ловушками и прерываниями.

Для целей управления имеются различные системные регистры. Дополнительно имеется два набора регистров, используемых для временного хранения, один набор --- для уровня драйверов устройств, и один --- для уровня ядра системы. Временные регистры для уровня драйверов устройств при каждом вызове драйвера устройства очищаются, по причинам, связанным с безопасностью. Эти регистры, в основном, используются для временного сохранения регистров общего назначения.

\section{Карта памяти}
Имеется три вида доступа к памяти: чтение, запись, и выполнение. Эти виды доступа различны, но могут комбинироваться. Например, доступ на выполнение не влечёт доступа по чтению. Доступ на запись и доступ на выполнение обычно комбинировать не следует, поскольку самомодифицирующийся код --- отталкивающ.

Карта памяти сохраняется на кристалле ЦП. Каждый элемент имеет три поля: виртуальный адрес (вплоть до 64 разрядов), права доступа (3 разряда), и слагаемое для трансляции адреса (вплоть до 64 разрядов). Разбиения памяти на страницы нет. Вместо этого имеются блоки памяти переменных размеров.

Элементы карты памяти обязаны всё время храниться в отсортированном виде, так, чтобы каждый блок памяти заканчивался там, где начинается следующий блок. Адреса обязательно должны быть кратны 8. Каждый поток имеет свою собственную карту памяти. Типичная карта памяти для потока приложения может выглядеть примерно так:

\begin{longtable} {|p{22mm}|p{30mm}|l|p{80mm}|}
\caption{Пример карты памяти} \\
\endfirsthead
\endhead
\hline
\bfseries Начальный адрес & \bfseries Права & \bfseries Слагаемое & \bfseries Комментарий  \\ \hline
0x10000                   & чтение          & 0                   & Секция CONST.\\
0x10100                   & выполнение      & 0                   & Секция CODE. \\
0x10800                   & нет             & 0                   & Принадлежит другим процессам. \\
0x20000                   & чтение, запись  & 0                   & Основные разделы STACK, DATA, BSS, HEAP. \\
0x24000                   & нет             & 0                   & Принадлежит другим процессам. \\
0x30000                   & чтение, запись  & 0                   & Секция STACK потока, блок окружения потока, и статические данные потока. \\
0x32000                   & нет             & 0                   & Остальное принадлежит другим процессам. \\ \hline
\end{longtable}

Может быть некоторое количество дополнительных элементов, для блоков памяти, разделяемых между процессами, и для безопасно изолированных блоков памяти. В случае, когда память становится фрагментированной, блок виртуальной памяти может иметь несколько элементов. Слагаемые используются для того, чтобы сохранить виртуальные адреса блоков смежными, в то время как физические адреса смежными не являются. Начальные адреса ---  это адреса в виртуальной памяти.

Размер карты памяти --- переменный. Максимальный размер зависит от реализации. На кристалле имеется по меньшей мере три карты памяти, по одной для каждого уровня привилегий, что делает переходы между уровнями быстрыми. Пространство на кристалле, используемое для карты памяти. Область на кристалле, используемая для карт памяти, может быть реконфигурируемой, так что в случае, когда карты памяти малы, карты памяти многих процессов могут оставаться на кристалле.

Карты памяти управляются уровнем ядра системы. Команды read\_memory\_map и write\_memory\_map используют механизм векторного цикла для быстрой манипуляции картами памяти.

Методы устранения фрагментации памяти, описанные на с.~ \pageref{memoryManagement}, важны для сохранения карт памяти малыми.

Переключения задач будут очень быстрыми, поскольку мы заменили большие таблицы страниц и буферы ассоциативной трансляции (translation-lookaside-buffer, TLB) традиционных систем малой хранящейся на кристалле картой памяти, что делает систему подходящей для операционных систем реального времени.

\section{Стек вызовов}
Возможно наличие либо унифицированного стека (и для данных функций, и для адресов возврата), либо двух отдельных стеков. См. с.~\pageref{callStackAlternatives}. В настоящее время ForwardCom поддерживает обе системы. Двухстековая система --- безопаснее и эффективнее, тогда как одностековая система может использоваться для малых процессоров, где предпочтительнее более простая одностековая система.

У двухстековой системы имеется стек вызовов, сохраняемый внутри ЦП, а не в ОЗУ. Требуется метод сохранения этого стека, когда он заполнен. Данный метод схож с методом, используемым для сохранения карты памяти, как описано выше, использующим векторные обращения к памяти. Должна быть возможна манипуляция со стеком вызовов, для переключений задач и для раскрутки стека в обработчике исключения.

\section{Системные вызовы и системные функции} \label{systemCallIDSystem}
Вызовы системных функций выполняются с помощью команды системного вызова (sys\_call). Команда системного вызова использует не адреса, а номера, ID. Каждый номер (ID) состоит из (в младшей половине) ID функции, и (в старшей половине) ID модуля. ID модуля идентифицирует модуль системы или драйвер устройства. У ядра системы ID = 0. Каждая часть ID может быть либо 16--разрядной, либо 32--разрядной, так что скомбинированный ID может быть либо 32--разрядным, либо 64--разрядным.

Дополнительным модулям системы и драйверам устройств нет необходимости иметь фиксированные номера ID, поскольку это потребовало бы некоторого центрального авторитета, присваивающего эти номера. Вместо этого программа будет должна запросить номер ID, задав имя модуля. Функции в пределах модуля могут иметь фиксированные или переменные номера ID.

Будет системная функция (с фиксированным номером ID), принимающая в качестве аргументов имя модуля и функции, и возвращающая номер ID. Номер ID  таким способом может быть подобран при первом вызове этой функции.

Номер ID системной функции может быть помещён в программу тремя способами:
\begin{enumerate}
\item Наиболее важные системные функции имеют фиксированные номера ID, которые можно вставить во время компиляции.

\item Номер ID может быть найден во время загрузки, тем же способом, что и при компоновке во время загрузки. Это описано на с.~\pageref{loadTimeLinking}. Загрузчик найдёт номер ID и вставит его в код перед запуском программы.

\item Номер ID находится во время выполнения, перед первым вызовом желаемой функции. 
\end{enumerate}

Соглашения вызова для системных функций --- те же, что и для других функций, использующих регистры для параметров и для возврата значения. Регистры, используемые для параметров, определяются общим соглашением вызова. Соглашения вызова описаны на с.~\pageref{functionCallingConventions}. Регистры для параметров не следует путать с операндами для команды системного вызова.

Команда системного вызова имеет три операнда. Первый операнд --- скомбинированный ID, помещённый в регистр (RT) или в непосредственно заданную константу. Второй операнд (RD) --- указатель на блок памяти, который может быть использован для передачи данных между вызывающей программой и системной функцией. Третий параметр (RS) --- размер этого блока памяти. Последние два параметра должны быть кратны 8. 

Вызывающий поток обязан иметь право на доступ к блоку памяти, который он разделяет с системной функцией. Это может быть право на чтение, право на запись, или и на то, и на другое. Эти права доступа передаются системной функции. У системной функции нет прав доступа ни к какой другой части памяти приложения.

С системными вызовами невозможно использовать указатели на функции обратного вызова, поскольку исполняемая память с системной функцией разделяться не может. Вместо этого системная функция может вызвать экспортируемую функцию, предоставляемую приложением, используя метод для межпроцессных вызовов, описанный ниже.

Функциям драйвера устройства предпочтительнее иметь отдельные стеки. Системный вызов идёт сначала в ядро системы, которое назначает стек для функции драйвера устройства и создаёт карту памяти для неё перед перенаправлением вызова на желаемую функцию. Во время этого перенаправления предпочтительнее не использовать никакого стека. Два регистра, идентифицирующих блок разделяемой памяти, копируются в специальные регистры, доступные вызванной функции. Системная функция выполняется в том же потоке, что и вызвавшее её приложение, но не с тем же самым стеком. 

Старые значения указателя команд, указателя стека, регистра DATAP и карты памяти сохраняются в системных регистрах, чтобы быть восстановленными командой системного возврата. 

Системным функциям, драйверам устройств, и обработчикам прерываний разрешается использовать все регистры общего назначения и векторные регистры, если они сохраняются и восстанавливаются согласно нормальным соглашениям вызова. Обработчики прерываний обязаны сохранять и восстанавливать все регистры, которые они используют.

Предоставляется метод для получения сведений об использовании регистров системной функцией, так что возможен их вызов с помощью соглашений об использовании регистров или методом 1, или методом 2, описанным на с.~\pageref{registerUsageConvention}. Использование стека системными функциями не имеет никакого отношения к вызывающему, ибо они не используют стек вызова прикладной программы.

Некоторые важные системные функции обязательно должны быть стандартизированы и доступны во всех операционных системах, что сделает возможным, например, создание сторонней библиотеки функций, работающей во всех операционных системах, даже если этой библиотеке нужно вызывать системные функции. Это также облегчит адаптацию программ для разных операционных систем. Список системных функций, которые могли бы быть стандартизированы, включает функции для создания потоков, синхронизации потоков, установки приоритета потоков, выделения памяти, измерения времени, системные сведения, обращение к переменным окружения, и т.д.

Следовало бы отобрать системные библиотеки, предоставляющие наиболее распространённые виды пользовательского интерфейса, такие, как графический пользовательский интерфейс, консольный режим, и серверный режим. Эти библиотеки пользовательского интерфейса следует предоставлять для каждой операционной системы, которая может работать на нашей архитектуре, так что одна и та же исполняемая программа может работать в разных операционных системах, просто посредством компоновки, в момент загрузки, с подходящей библиотекой пользовательского интерфейса. Такие библиотеки пользовательского интерфейса могут быть основаны на существующих платформенно--независимых библиотеках GUI, таких, как, например, wxWidgets или QT. Все библиотеки пользовательского интерфейса обязаны поддерживать функцию error\_message, упомянутую ниже. 

\section{Межпроцессные вызовы} \label{interProcessCalls}
Межпроцессные вызовы опосредуются системной функцией. Работает это следующим образом. Прикладная программа может экспортировать функцию с элементом в заголовке своего исполняемого файла. Другое приложение может получить доступ к этой экспортированной функции посредством вызова системной функции, проверяющей разрешения и переключающей карту памяти, регистры DATAP и THREADP, и указатель стека перед вызовом экспортированной функции, и переключающей обратно перед возвратом в вызвавшую программу. Вызов возникнет как отдельный поток вызванной программы. Регистры общего назначения и векторные регистры могут использоваться для передачи параметров и возвращаемого значения так же, как это было бы для нормальных функций. Данный механизм не порождает никакой разделяемой вызвавшим и вызывающим памяти. Следовательно, экспортируемая функция обязана использовать лишь простые типы, помещающиеся в регистры, для своих параметров и для возвращаемого значения. Блок памяти может разделяться между двумя процессами так, как описано на с.~\pageref{sharedMemory}. 

\section{Обработка сообщений об ошибках} \label{errorMessageHandling}
Имеется необходимость в стандартизированном способе сообщения об ошибках, возникающих в программе. Многим имеющимся системам не удаётся удовлетворить эту потребность, или они используют методы, которые либо не переносимы, либо не являются потокобезопасными. В частности, от такого стандарта выиграли бы следующие ситуации.
\begin{enumerate}
\item Библиотека функций обнаруживает ошибку, например, неверный параметр, и ей нужно сообщить об ошибке вызывающей программе. Вызывающая программа примет решение: восстановиться ли после ошибки, или завершить работу.

\item Из--за числовой ошибки порождается ловушка. Программе не удаётся перехватить её как исключение, или в языке программирования нет поддержки структурной обработки исключений. Операционная система обязана выдать информативное сообщение об ошибке.

\item Программа может выполняться в разных окружениях, требующих разных форм обработки ошибок. 

\item Библиотеке функций в форме исходного кода, библиотеки классов, или любой другой части кода, необходимо сообщать об ошибке, не зная, какая используется парадигма пользовательского интерфейса (например, консольный режим или графический пользовательский интерфейс). Необходим стандартизированный способ передачи сообщения об ошибке в операционную систему или каркас пользовательского интерфейса, которые обязаны представить сообщение об ошибке пользователю способом, подходящим для пользовательского интерфейса (например, всплытие окна с сообщением, печать в stderr, печать в лог--файл, или посылка сообщения администратору).
\end{enumerate}

\label{errorReportFunction}
Для этой цели предлагается определить стандартную библиотечную функцию, с именем error\_message. Все каркасы пользовательского интерфейса обязаны определять эту функцию. Возможен автоматический выбор различных версий этой функции во время выполнения, в зависимости от настроек системы, используя диспетчеризацию, описанную на с.~\pageref{libraryFunctionDispatchSystem}. Головная программа может перекрывать эту функцию, определяя свою собственную функцию с тем же именем.

Функция  error\_message обязана иметь следующие параметры: числовой код ошибки; указатель на строку, предоставляющую сообщение об ошибке; и указатель на другую строку, дающую имя функции, в которой возникла ошибка. Эти строки представляют собой завершающиеся нулём строки, в кодировке UTF-8. Сообщение об ошибке --- по умолчанию на английском языке. Поддержки многих разных языков (см.  \href{https://en.wikibooks.org/wiki/Usability_for_Nerds/Software/Internationalization}{эту ссылку} по поводу обсуждения проблем с интернационализацией) требовать неразумно. Вместо этого руководство на желаемом языке может содержать список кодов ошибок.

Строка сообщения об ошибке может включать числовые значения и диагностические сведения, такие, как значение параметра, находящегося вне диапазона.

Функция error\_message может возвращать управление, а может и не возвращать. Если она возвращает управление, то вызвавшая функция обязана изящно вернуть управление. Как вариант, функция error\_message может завершить приложение, либо может возбудить исключение или ловушку, которые обрабатываются операционной системой, в случае, если исключение не перехвачено программой.
\end{document}